<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>I See You - Cyberpunk Head Tracking</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: #00ffff;
            text-align: center;
        }

        #overlay h1 {
            font-size: 48px;
            letter-spacing: 10px;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            margin-bottom: 10px;
        }

        #start-btn {
            padding: 15px 50px;
            font-size: 18px;
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            cursor: pointer;
            margin-top: 30px;
            font-family: 'Courier New', monospace;
            letter-spacing: 3px;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        #start-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px #00ffff;
        }

        #debug-video,
        #debug-canvas {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 160px;
            height: 120px;
            z-index: 100;
            opacity: 0.7;
            transform: scaleX(-1);
            border: 1px solid #00ffff;
            background: #000;
            pointer-events: none;
        }

        #status {
            margin-bottom: 20px;
            font-size: 14px;
            color: #666;
            letter-spacing: 2px;
        }

        #fullscreen-btn {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1001;
            padding: 8px 12px;
            font-size: 12px;
            background: transparent;
            color: #00ffff;
            border: 1px solid #00ffff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s ease;
        }

        #fullscreen-btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 3px
            );
            opacity: 0.3;
        }
    </style>
</head>

<body>

    <div id="overlay">
        <h1>I SEE YOU</h1>
        <p style="color: #00aa88; max-width: 500px; line-height: 1.8;">
            [ NEURAL INTERFACE DETECTED ]<br>
            Initializing holographic projection system...<br>
            Webcam required for spatial tracking.
        </p>
        <div id="status">AWAITING USER INPUT</div>
        <button id="start-btn">Initialize</button>
    </div>

    <div class="scanlines"></div>

    <video id="debug-video" playsinline style="display:none"></video>
    <canvas id="debug-canvas"></canvas>

    <div id="canvas-container"></div>

    <button id="fullscreen-btn">[ FULLSCREEN ]</button>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Global state
        let headGroup = null;
        let eyeLeftGroup = null;
        let eyeRightGroup = null;
        let headPointsUniforms = null;
        let headWireUniforms = null;

        const params = {
            modelScale: 1.0,
            modelZ: -25.0,
            modelY: 0.0,
            headTrackStrength: 1.2,
            eyeTrackStrength: 0.8,
            smoothing: 0.06,
            showDebug: true,
            glowIntensity: 1.5,
            pulseSpeed: 1.0,
            particleSize: 2.5,
            wireframeOpacity: 0.4,
            gridSpeed: 2.0
        };

        const SCREEN_WIDTH_CM = 30.0;
        const SCREEN_HEIGHT_CM = 20.0;
        const BOX_DEPTH_CM = 80.0;
        const DEFAULT_HEAD_Z = 60.0;
        const NEAR = 0.5;
        const FAR = 1000.0;

        const state = {
            head: new THREE.Vector3(0, 0, DEFAULT_HEAD_Z),
            targetHead: new THREE.Vector3(0, 0, DEFAULT_HEAD_Z),
            viewerPosition: new THREE.Vector3(0, 0, DEFAULT_HEAD_Z),
            trackingActive: false
        };

        // Setup renderer
        const container = document.getElementById('canvas-container');
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020208);
        const camera = new THREE.Camera();
        scene.add(camera);

        let gridUniforms;

        // --- Create Environment ---
        function createEnvironment() {
            const group = new THREE.Group();
            scene.add(group);

            const w = SCREEN_WIDTH_CM;
            const h = SCREEN_HEIGHT_CM;
            const d = BOX_DEPTH_CM;

            const vertices = [];
            const stepX = 2.5;
            const numZLines = 25;

            for (let x = -w / 2; x <= w / 2; x += stepX) {
                vertices.push(x, -h / 2, 0, x, -h / 2, -d);
                vertices.push(x, h / 2, 0, x, h / 2, -d);
            }

            for (let i = 0; i <= numZLines; i++) {
                const t = i / numZLines;
                const z = -d * Math.pow(t, 1.5);
                vertices.push(-w / 2, -h / 2, z, w / 2, -h / 2, z);
                vertices.push(-w / 2, h / 2, z, w / 2, h / 2, z);
                vertices.push(-w / 2, -h / 2, z, -w / 2, h / 2, z);
                vertices.push(w / 2, -h / 2, z, w / 2, h / 2, z);
            }

            for (let y = -h / 2; y <= h / 2; y += stepX) {
                vertices.push(-w / 2, y, 0, -w / 2, y, -d);
                vertices.push(w / 2, y, 0, w / 2, y, -d);
            }

            const gridGeo = new THREE.BufferGeometry();
            gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            gridUniforms = {
                time: { value: 0 },
                color: { value: new THREE.Color(0x00ffff) }
            };

            const gridMat = new THREE.ShaderMaterial({
                uniforms: gridUniforms,
                vertexShader: `
                    varying vec3 vPos;
                    void main() {
                        vPos = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    varying vec3 vPos;
                    void main() {
                        float pulse = sin(vPos.z * 0.08 + time * 2.0) * 0.5 + 0.5;
                        float glow = 0.2 + pulse * 0.5;
                        float fade = smoothstep(-80.0, 0.0, vPos.z);
                        fade = pow(fade, 1.8);
                        gl_FragColor = vec4(color * glow, fade * (glow + 0.1));
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            group.add(new THREE.LineSegments(gridGeo, gridMat));

            // Dark box
            const boxGeo = new THREE.BoxGeometry(w, h, d);
            boxGeo.translate(0, 0, -d / 2);
            const wallMat = new THREE.MeshBasicMaterial({ color: 0x010105, side: THREE.BackSide });
            group.add(new THREE.Mesh(boxGeo, wallMat));
        }

        createEnvironment();

        // --- Generate Cyberpunk Head ---
        function createCyberpunkHead() {
            headGroup = new THREE.Group();
            scene.add(headGroup);

            const headScale = 8;
            const points = [];
            const colors = [];

            // Generate head shape using superellipsoid + noise
            // Head: squashed sphere, elongated vertically
            const numPoints = 8000;

            for (let i = 0; i < numPoints; i++) {
                // Spherical coordinates with head-like deformation
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                // Base radius with head-like shape modifications
                let r = 1.0;

                // Make it taller (head is taller than wide)
                const yFactor = Math.cos(phi);
                r *= 1.0 + 0.15 * yFactor;

                // Flatten the back
                const xDir = Math.sin(phi) * Math.cos(theta);
                if (xDir < -0.3) r *= 0.85;

                // Chin area
                if (yFactor < -0.6 && Math.sin(phi) * Math.sin(theta) > 0) {
                    r *= 0.75 + 0.2 * (yFactor + 1);
                }

                // Forehead bulge
                if (yFactor > 0.5 && xDir > 0) {
                    r *= 1.05;
                }

                // Slight noise
                r *= 0.95 + Math.random() * 0.1;

                const x = r * Math.sin(phi) * Math.cos(theta) * headScale * 0.85;
                const y = r * Math.cos(phi) * headScale * 1.1;
                const z = r * Math.sin(phi) * Math.sin(theta) * headScale;

                points.push(x, y, z);

                // Color variation - cyan to purple gradient
                const t = (y / headScale + 1) * 0.5;
                colors.push(
                    0.0 + t * 0.5,    // R
                    0.8 + t * 0.2,    // G
                    1.0               // B
                );
            }

            // Add feature lines (facial structure hints)
            // Eye sockets area
            for (let i = 0; i < 500; i++) {
                const angle = Math.random() * Math.PI * 2;
                const eyeRadius = 0.8 + Math.random() * 0.4;
                const eyeX = (i < 250 ? -2.5 : 2.5);
                const eyeY = 2;
                const eyeZ = 6 + Math.cos(angle) * eyeRadius;

                points.push(
                    eyeX + Math.cos(angle) * eyeRadius * 1.2,
                    eyeY + Math.sin(angle) * eyeRadius,
                    eyeZ
                );
                colors.push(0.2, 1.0, 1.0);
            }

            // Nose ridge
            for (let i = 0; i < 200; i++) {
                const t = Math.random();
                points.push(
                    (Math.random() - 0.5) * 0.5,
                    -1 + t * 4,
                    7 + t * 1.5 + (Math.random() - 0.5) * 0.3
                );
                colors.push(0.0, 0.9, 0.9);
            }

            // Mouth line
            for (let i = 0; i < 150; i++) {
                const t = (Math.random() - 0.5) * 2;
                points.push(
                    t * 2,
                    -4 + Math.sin(Math.abs(t) * Math.PI) * 0.3,
                    6.5 + (Math.random() - 0.5) * 0.2
                );
                colors.push(0.5, 0.2, 0.8);
            }

            const pointsGeo = new THREE.BufferGeometry();
            pointsGeo.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            pointsGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            headPointsUniforms = {
                time: { value: 0 },
                glowIntensity: { value: params.glowIntensity },
                size: { value: params.particleSize }
            };

            const pointsMat = new THREE.ShaderMaterial({
                uniforms: headPointsUniforms,
                vertexShader: `
                    attribute vec3 color;
                    uniform float time;
                    uniform float size;
                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        vColor = color;

                        vec3 pos = position;

                        // Subtle floating animation
                        pos.y += sin(time * 2.0 + position.x * 0.5) * 0.05;
                        pos.x += cos(time * 1.5 + position.y * 0.3) * 0.03;

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;

                        // Size attenuation
                        gl_PointSize = size * (150.0 / -mvPosition.z);

                        // Alpha based on depth and random flicker
                        float flicker = sin(time * 10.0 + position.x * 50.0) * 0.1 + 0.9;
                        vAlpha = flicker;
                    }
                `,
                fragmentShader: `
                    uniform float glowIntensity;
                    uniform float time;
                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        // Circular point with soft edge
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        if (dist > 0.5) discard;

                        float glow = 1.0 - dist * 2.0;
                        glow = pow(glow, 1.5);

                        vec3 finalColor = vColor * glowIntensity * glow;
                        float alpha = glow * vAlpha;

                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const headPoints = new THREE.Points(pointsGeo, pointsMat);
            headGroup.add(headPoints);

            // Add wireframe skull outline
            const skullGeo = new THREE.SphereGeometry(headScale * 0.95, 24, 18);
            // Deform to head shape
            const skullPos = skullGeo.attributes.position;
            for (let i = 0; i < skullPos.count; i++) {
                const x = skullPos.getX(i);
                const y = skullPos.getY(i);
                const z = skullPos.getZ(i);

                let scale = 1.0;
                // Elongate Y
                skullPos.setY(i, y * 1.15);
                // Narrow sides
                skullPos.setX(i, x * 0.9);
                // Push face forward slightly
                if (z > 0) skullPos.setZ(i, z * 1.05);
            }

            headWireUniforms = {
                time: { value: 0 },
                opacity: { value: params.wireframeOpacity }
            };

            const wireMat = new THREE.ShaderMaterial({
                uniforms: headWireUniforms,
                vertexShader: `
                    varying vec3 vPos;
                    void main() {
                        vPos = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    varying vec3 vPos;
                    void main() {
                        float scanline = sin(vPos.y * 20.0 + time * 5.0) * 0.5 + 0.5;
                        vec3 color = vec3(0.0, 0.8, 1.0);
                        float alpha = opacity * (0.3 + scanline * 0.3);
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                wireframe: true,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const skullWire = new THREE.Mesh(skullGeo, wireMat);
            headGroup.add(skullWire);

            // Create glowing eyes
            createEyes();

            headGroup.position.z = params.modelZ;
        }

        function createEyes() {
            const eyeGeometry = new THREE.SphereGeometry(1.2, 16, 16);

            const eyeMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    innerColor: { value: new THREE.Color(0xff0040) },
                    outerColor: { value: new THREE.Color(0x00ffff) }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 innerColor;
                    uniform vec3 outerColor;
                    varying vec3 vNormal;
                    varying vec3 vPosition;

                    void main() {
                        // Glowing eye effect
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                        vec3 color = mix(innerColor, outerColor, fresnel);

                        // Pulsing
                        float pulse = sin(time * 3.0) * 0.2 + 0.8;
                        color *= pulse;

                        // Inner glow
                        float center = 1.0 - length(vPosition.xy) * 0.5;
                        center = pow(max(center, 0.0), 2.0);

                        gl_FragColor = vec4(color * (0.5 + center), 0.9);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            // Left eye
            eyeLeftGroup = new THREE.Group();
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            eyeLeftGroup.add(leftEye);
            eyeLeftGroup.position.set(-2.5, 2, 6.5);
            headGroup.add(eyeLeftGroup);

            // Right eye
            eyeRightGroup = new THREE.Group();
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            eyeRightGroup.add(rightEye);
            eyeRightGroup.position.set(2.5, 2, 6.5);
            headGroup.add(eyeRightGroup);

            // Add pupil glow points
            const pupilGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const pupilMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });

            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.z = 0.9;
            eyeLeftGroup.add(leftPupil);

            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat.clone());
            rightPupil.position.z = 0.9;
            eyeRightGroup.add(rightPupil);
        }

        createCyberpunkHead();

        // --- Controls ---
        function setupControls() {
            const gui = new dat.GUI();

            const folderHead = gui.addFolder('Head');
            folderHead.add(params, 'modelScale', 0.5, 2.0).name('Scale').onChange(v => {
                headGroup.scale.setScalar(v);
            });
            folderHead.add(params, 'modelZ', -50, 0).name('Depth').onChange(v => {
                headGroup.position.z = v;
            });
            folderHead.add(params, 'modelY', -10, 10).name('Height').onChange(v => {
                headGroup.position.y = v;
            });
            folderHead.open();

            const folderTracking = gui.addFolder('Tracking');
            folderTracking.add(params, 'headTrackStrength', 0, 2.0).name('Head Response');
            folderTracking.add(params, 'eyeTrackStrength', 0, 1.5).name('Eye Response');
            folderTracking.add(params, 'smoothing', 0.02, 0.2).name('Smoothing');
            folderTracking.add(params, 'showDebug').name('Show Webcam').onChange(val => {
                document.getElementById('debug-canvas').style.display = val ? 'block' : 'none';
            });
            folderTracking.open();

            const folderVisuals = gui.addFolder('Visuals');
            folderVisuals.add(params, 'glowIntensity', 0.5, 3.0).name('Glow');
            folderVisuals.add(params, 'particleSize', 1.0, 5.0).name('Particle Size');
            folderVisuals.add(params, 'wireframeOpacity', 0, 1.0).name('Wireframe');
            folderVisuals.add(params, 'pulseSpeed', 0, 3.0).name('Pulse Speed');
            folderVisuals.add(params, 'gridSpeed', 0, 5.0).name('Grid Speed');
        }

        setupControls();

        // --- Off-Axis Projection ---
        function updateCamera(head) {
            camera.position.copy(head);
            const dist = head.z;
            if (dist < 0.1) return;

            const halfW = SCREEN_WIDTH_CM / 2;
            const halfH = SCREEN_HEIGHT_CM / 2;
            const scale = NEAR / dist;

            camera.projectionMatrix.makePerspective(
                (-halfW - head.x) * scale,
                (halfW - head.x) * scale,
                (halfH - head.y) * scale,
                (-halfH - head.y) * scale,
                NEAR, FAR
            );
        }

        // --- Head Look-At ---
        function updateHeadLookAt() {
            if (!headGroup) return;

            const viewerPos = state.viewerPosition.clone();
            const headPos = new THREE.Vector3();
            headGroup.getWorldPosition(headPos);
            const lookDir = viewerPos.clone().sub(headPos);

            // Calculate angles
            const angleY = Math.atan2(lookDir.x, lookDir.z) * params.headTrackStrength;
            const angleX = Math.atan2(-lookDir.y, Math.sqrt(lookDir.x * lookDir.x + lookDir.z * lookDir.z)) * params.headTrackStrength;

            const maxRotY = Math.PI / 2.5;
            const maxRotX = Math.PI / 3;

            const targetRotY = THREE.MathUtils.clamp(angleY, -maxRotY, maxRotY);
            const targetRotX = THREE.MathUtils.clamp(angleX, -maxRotX, maxRotX);

            // Smooth rotation
            headGroup.rotation.y = THREE.MathUtils.lerp(headGroup.rotation.y, targetRotY, params.smoothing * 1.5);
            headGroup.rotation.x = THREE.MathUtils.lerp(headGroup.rotation.x, targetRotX, params.smoothing * 1.5);

            // Eye tracking (faster, more responsive)
            if (eyeLeftGroup && eyeRightGroup) {
                const eyeAngleY = angleY * params.eyeTrackStrength;
                const eyeAngleX = angleX * params.eyeTrackStrength;

                const maxEyeRot = Math.PI / 4;
                const eyeTargetY = THREE.MathUtils.clamp(eyeAngleY, -maxEyeRot, maxEyeRot);
                const eyeTargetX = THREE.MathUtils.clamp(eyeAngleX, -maxEyeRot, maxEyeRot);

                eyeLeftGroup.rotation.y = THREE.MathUtils.lerp(eyeLeftGroup.rotation.y, eyeTargetY, params.smoothing * 2.5);
                eyeLeftGroup.rotation.x = THREE.MathUtils.lerp(eyeLeftGroup.rotation.x, eyeTargetX, params.smoothing * 2.5);
                eyeRightGroup.rotation.y = THREE.MathUtils.lerp(eyeRightGroup.rotation.y, eyeTargetY, params.smoothing * 2.5);
                eyeRightGroup.rotation.x = THREE.MathUtils.lerp(eyeRightGroup.rotation.x, eyeTargetX, params.smoothing * 2.5);
            }
        }

        // --- Face Tracking ---
        async function startTracking() {
            try {
                const video = document.getElementById('debug-video');
                const canvas = document.getElementById('debug-canvas');
                const ctx = canvas.getContext('2d');

                const faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });

                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                faceMesh.onResults(results => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

                    if (results.multiFaceLandmarks.length > 0) {
                        state.trackingActive = true;
                        const lm = results.multiFaceLandmarks[0];
                        const lIris = lm[468], rIris = lm[473];

                        if (lIris && rIris) {
                            const cx = (lIris.x + rIris.x) / 2;
                            const cy = (lIris.y + rIris.y) / 2;

                            const dx = lIris.x - rIris.x;
                            const dy = lIris.y - rIris.y;
                            const dPx = Math.sqrt(dx * dx + dy * dy);

                            let z = 4.5 / dPx;
                            z = THREE.MathUtils.clamp(z, 15, 120);

                            const SENSITIVITY = 2.5;
                            const wx = (0.5 - cx) * SCREEN_WIDTH_CM * SENSITIVITY;
                            const wy = (0.5 - cy) * SCREEN_HEIGHT_CM * SENSITIVITY * 0.8;

                            state.targetHead.set(
                                THREE.MathUtils.clamp(wx, -50, 50),
                                THREE.MathUtils.clamp(wy, -50, 50),
                                z
                            );

                            // Debug viz
                            ctx.fillStyle = '#00ffff';
                            ctx.shadowColor = '#00ffff';
                            ctx.shadowBlur = 10;
                            ctx.beginPath();
                            ctx.arc(cx * canvas.width, cy * canvas.height, 4, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.font = '10px Courier New';
                            ctx.fillText(`DIST: ${z.toFixed(0)}cm`, 5, 15);
                            ctx.fillText(`X: ${wx.toFixed(1)}`, 5, 27);
                        }
                    }
                });

                const mediapipeCamera = new Camera(video, {
                    onFrame: async () => await faceMesh.send({ image: video }),
                    width: 640,
                    height: 480
                });

                await mediapipeCamera.start();
                document.getElementById('overlay').style.display = 'none';

            } catch (e) {
                console.error(e);
                document.getElementById('status').innerText = "ERROR: " + e.message;
            }
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('status').innerText = "INITIALIZING NEURAL LINK...";
            startTracking();
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update uniforms
            if (gridUniforms) gridUniforms.time.value = time * params.gridSpeed;
            if (headPointsUniforms) {
                headPointsUniforms.time.value = time * params.pulseSpeed;
                headPointsUniforms.glowIntensity.value = params.glowIntensity;
                headPointsUniforms.size.value = params.particleSize;
            }
            if (headWireUniforms) {
                headWireUniforms.time.value = time * params.pulseSpeed;
                headWireUniforms.opacity.value = params.wireframeOpacity;
            }

            // Update eye materials
            if (eyeLeftGroup) {
                eyeLeftGroup.children[0].material.uniforms.time.value = time;
                eyeRightGroup.children[0].material.uniforms.time.value = time;
            }

            // Smooth tracking
            state.head.lerp(state.targetHead, params.smoothing);
            state.viewerPosition.copy(state.head);

            updateCamera(state.head);
            updateHeadLookAt();

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(console.warn);
            } else {
                document.exitFullscreen();
            }
        });

        document.addEventListener('fullscreenchange', () => {
            document.getElementById('fullscreen-btn').textContent =
                document.fullscreenElement ? '[ EXIT ]' : '[ FULLSCREEN ]';
        });
    </script>
</body>

</html>
