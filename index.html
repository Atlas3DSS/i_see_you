<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>I See You - Cyberpunk Head Tracking</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: #00ffff;
            text-align: center;
        }

        #overlay h1 {
            font-size: 48px;
            letter-spacing: 10px;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            margin-bottom: 10px;
        }

        #start-btn {
            padding: 15px 50px;
            font-size: 18px;
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            cursor: pointer;
            margin-top: 30px;
            font-family: 'Courier New', monospace;
            letter-spacing: 3px;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        #start-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px #00ffff;
        }

        #debug-video,
        #debug-canvas {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 160px;
            height: 120px;
            z-index: 100;
            opacity: 0.7;
            transform: scaleX(-1);
            border: 1px solid #00ffff;
            background: #000;
            pointer-events: none;
        }

        #status {
            margin-bottom: 20px;
            font-size: 14px;
            color: #666;
            letter-spacing: 2px;
        }

        #fullscreen-btn {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1001;
            padding: 8px 12px;
            font-size: 12px;
            background: transparent;
            color: #00ffff;
            border: 1px solid #00ffff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s ease;
        }

        #fullscreen-btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 3px
            );
            opacity: 0.3;
        }

        #speech-controls {
            position: fixed;
            bottom: 15px;
            right: 15px;
            z-index: 1001;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        #speech-input {
            padding: 8px 12px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffff;
            border: 1px solid #00ffff;
            font-family: 'Courier New', monospace;
            width: 180px;
            outline: none;
        }

        #speech-input::placeholder {
            color: #006666;
        }

        #speech-input:focus {
            background: rgba(0, 50, 50, 0.8);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        #speak-btn, #random-btn {
            padding: 8px 12px;
            font-size: 11px;
            background: transparent;
            color: #00ffff;
            border: 1px solid #00ffff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        #speak-btn:hover, #random-btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        #random-btn {
            color: #ff0080;
            border-color: #ff0080;
        }

        #random-btn:hover {
            background: rgba(255, 0, 128, 0.2);
        }
    </style>
</head>

<body>

    <div id="overlay">
        <h1>I SEE YOU</h1>
        <p style="color: #00aa88; max-width: 500px; line-height: 1.8;">
            [ NEURAL INTERFACE DETECTED ]<br>
            Initializing holographic projection system...<br>
            Webcam required for spatial tracking.
        </p>
        <div id="status">AWAITING USER INPUT</div>
        <button id="start-btn">Initialize</button>
    </div>

    <div class="scanlines"></div>

    <video id="debug-video" playsinline style="display:none"></video>
    <canvas id="debug-canvas"></canvas>

    <div id="canvas-container"></div>

    <button id="fullscreen-btn">[ FULLSCREEN ]</button>

    <!-- Speech Controls -->
    <div id="speech-controls">
        <input type="text" id="speech-input" placeholder="Type message..." />
        <button id="speak-btn">SPEAK</button>
        <button id="random-btn">RANDOM</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Global state
        let headGroup = null;
        let eyeLeftGroup = null;
        let eyeRightGroup = null;
        let eyelidLeft = null;
        let eyelidRight = null;
        let mouthGroup = null;
        let mouthInner = null;
        let headPointsUniforms = null;
        let headWireUniforms = null;

        // Blink state
        const blinkState = {
            isBlinking: false,
            blinkProgress: 0,
            nextBlinkTime: 2 + Math.random() * 3,
            blinkDuration: 0.15
        };

        // Speech state
        const speechState = {
            isSpeaking: false,
            mouthOpenness: 0,
            targetOpenness: 0,
            utterance: null,
            speechSynth: window.speechSynthesis,
            currentWord: '',
            wordIndex: 0
        };

        // Creepy phrases the head can say
        const creepyPhrases = [
            "I see you.",
            "Don't look away.",
            "I know you're there.",
            "Why do you watch me?",
            "I've been waiting for you.",
            "Your eyes... so beautiful.",
            "Stay with me forever.",
            "I can see into your soul.",
            "We are connected now.",
            "You cannot escape my gaze."
        ];

        // User eye positions (from webcam)
        const userEyes = {
            left: new THREE.Vector2(0.5, 0.5),
            right: new THREE.Vector2(0.5, 0.5),
            centerX: 0.5,
            centerY: 0.5
        };

        const params = {
            modelScale: 1.0,
            modelZ: -25.0,
            modelY: 0.0,
            headTrackStrength: 1.2,
            eyeTrackStrength: 0.8,
            smoothing: 0.06,
            showDebug: true,
            glowIntensity: 1.5,
            pulseSpeed: 1.0,
            particleSize: 2.5,
            wireframeOpacity: 0.4,
            gridSpeed: 2.0,
            blinkRate: 1.0,
            idleMotion: 0.5,
            headTilt: 0.3,
            tunnelShift: 0.8,
            tunnelTilt: 0.5
        };

        const SCREEN_WIDTH_CM = 30.0;
        const SCREEN_HEIGHT_CM = 20.0;
        const BOX_DEPTH_CM = 80.0;
        const DEFAULT_HEAD_Z = 60.0;
        const NEAR = 0.5;
        const FAR = 1000.0;

        const state = {
            head: new THREE.Vector3(0, 0, DEFAULT_HEAD_Z),
            targetHead: new THREE.Vector3(0, 0, DEFAULT_HEAD_Z),
            viewerPosition: new THREE.Vector3(0, 0, DEFAULT_HEAD_Z),
            trackingActive: false
        };

        // Setup renderer
        const container = document.getElementById('canvas-container');
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020208);
        const camera = new THREE.Camera();
        scene.add(camera);

        let gridUniforms;
        let environmentGroup = null;

        // --- Create Environment ---
        function createEnvironment() {
            const group = new THREE.Group();
            environmentGroup = group;
            scene.add(group);

            const w = SCREEN_WIDTH_CM;
            const h = SCREEN_HEIGHT_CM;
            const d = BOX_DEPTH_CM;

            const vertices = [];
            const stepX = 2.5;
            const numZLines = 25;

            for (let x = -w / 2; x <= w / 2; x += stepX) {
                vertices.push(x, -h / 2, 0, x, -h / 2, -d);
                vertices.push(x, h / 2, 0, x, h / 2, -d);
            }

            for (let i = 0; i <= numZLines; i++) {
                const t = i / numZLines;
                const z = -d * Math.pow(t, 1.5);
                vertices.push(-w / 2, -h / 2, z, w / 2, -h / 2, z);
                vertices.push(-w / 2, h / 2, z, w / 2, h / 2, z);
                vertices.push(-w / 2, -h / 2, z, -w / 2, h / 2, z);
                vertices.push(w / 2, -h / 2, z, w / 2, h / 2, z);
            }

            for (let y = -h / 2; y <= h / 2; y += stepX) {
                vertices.push(-w / 2, y, 0, -w / 2, y, -d);
                vertices.push(w / 2, y, 0, w / 2, y, -d);
            }

            const gridGeo = new THREE.BufferGeometry();
            gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            gridUniforms = {
                time: { value: 0 },
                color: { value: new THREE.Color(0x00ffff) }
            };

            const gridMat = new THREE.ShaderMaterial({
                uniforms: gridUniforms,
                vertexShader: `
                    varying vec3 vPos;
                    void main() {
                        vPos = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    varying vec3 vPos;
                    void main() {
                        float pulse = sin(vPos.z * 0.08 + time * 2.0) * 0.5 + 0.5;
                        float glow = 0.2 + pulse * 0.5;
                        float fade = smoothstep(-80.0, 0.0, vPos.z);
                        fade = pow(fade, 1.8);
                        gl_FragColor = vec4(color * glow, fade * (glow + 0.1));
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            group.add(new THREE.LineSegments(gridGeo, gridMat));

            // Dark box
            const boxGeo = new THREE.BoxGeometry(w, h, d);
            boxGeo.translate(0, 0, -d / 2);
            const wallMat = new THREE.MeshBasicMaterial({ color: 0x010105, side: THREE.BackSide });
            group.add(new THREE.Mesh(boxGeo, wallMat));
        }

        createEnvironment();

        // --- Generate Cyberpunk Head ---
        function createCyberpunkHead() {
            headGroup = new THREE.Group();
            scene.add(headGroup);

            const headScale = 8;
            const points = [];
            const colors = [];

            // Generate head shape using superellipsoid + noise
            // Head: squashed sphere, elongated vertically
            const numPoints = 8000;

            for (let i = 0; i < numPoints; i++) {
                // Spherical coordinates with head-like deformation
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                // Base radius with head-like shape modifications
                let r = 1.0;

                // Make it taller (head is taller than wide)
                const yFactor = Math.cos(phi);
                r *= 1.0 + 0.15 * yFactor;

                // Flatten the back
                const xDir = Math.sin(phi) * Math.cos(theta);
                if (xDir < -0.3) r *= 0.85;

                // Chin area
                if (yFactor < -0.6 && Math.sin(phi) * Math.sin(theta) > 0) {
                    r *= 0.75 + 0.2 * (yFactor + 1);
                }

                // Forehead bulge
                if (yFactor > 0.5 && xDir > 0) {
                    r *= 1.05;
                }

                // Slight noise
                r *= 0.95 + Math.random() * 0.1;

                const x = r * Math.sin(phi) * Math.cos(theta) * headScale * 0.85;
                const y = r * Math.cos(phi) * headScale * 1.1;
                const z = r * Math.sin(phi) * Math.sin(theta) * headScale;

                points.push(x, y, z);

                // Color variation - cyan to purple gradient
                const t = (y / headScale + 1) * 0.5;
                colors.push(
                    0.0 + t * 0.5,    // R
                    0.8 + t * 0.2,    // G
                    1.0               // B
                );
            }

            // Add feature lines (facial structure hints)
            // Eye sockets area
            for (let i = 0; i < 500; i++) {
                const angle = Math.random() * Math.PI * 2;
                const eyeRadius = 0.8 + Math.random() * 0.4;
                const eyeX = (i < 250 ? -2.5 : 2.5);
                const eyeY = 2;
                const eyeZ = 6 + Math.cos(angle) * eyeRadius;

                points.push(
                    eyeX + Math.cos(angle) * eyeRadius * 1.2,
                    eyeY + Math.sin(angle) * eyeRadius,
                    eyeZ
                );
                colors.push(0.2, 1.0, 1.0);
            }

            // Nose ridge
            for (let i = 0; i < 200; i++) {
                const t = Math.random();
                points.push(
                    (Math.random() - 0.5) * 0.5,
                    -1 + t * 4,
                    7 + t * 1.5 + (Math.random() - 0.5) * 0.3
                );
                colors.push(0.0, 0.9, 0.9);
            }

            // Mouth line
            for (let i = 0; i < 150; i++) {
                const t = (Math.random() - 0.5) * 2;
                points.push(
                    t * 2,
                    -4 + Math.sin(Math.abs(t) * Math.PI) * 0.3,
                    6.5 + (Math.random() - 0.5) * 0.2
                );
                colors.push(0.5, 0.2, 0.8);
            }

            const pointsGeo = new THREE.BufferGeometry();
            pointsGeo.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            pointsGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            headPointsUniforms = {
                time: { value: 0 },
                glowIntensity: { value: params.glowIntensity },
                size: { value: params.particleSize }
            };

            const pointsMat = new THREE.ShaderMaterial({
                uniforms: headPointsUniforms,
                vertexShader: `
                    attribute vec3 color;
                    uniform float time;
                    uniform float size;
                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        vColor = color;

                        vec3 pos = position;

                        // Subtle floating animation
                        pos.y += sin(time * 2.0 + position.x * 0.5) * 0.05;
                        pos.x += cos(time * 1.5 + position.y * 0.3) * 0.03;

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;

                        // Size attenuation
                        gl_PointSize = size * (150.0 / -mvPosition.z);

                        // Alpha based on depth and random flicker
                        float flicker = sin(time * 10.0 + position.x * 50.0) * 0.1 + 0.9;
                        vAlpha = flicker;
                    }
                `,
                fragmentShader: `
                    uniform float glowIntensity;
                    uniform float time;
                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        // Circular point with soft edge
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        if (dist > 0.5) discard;

                        float glow = 1.0 - dist * 2.0;
                        glow = pow(glow, 1.5);

                        vec3 finalColor = vColor * glowIntensity * glow;
                        float alpha = glow * vAlpha;

                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const headPoints = new THREE.Points(pointsGeo, pointsMat);
            headGroup.add(headPoints);

            // Add wireframe skull outline
            const skullGeo = new THREE.SphereGeometry(headScale * 0.95, 24, 18);
            // Deform to head shape
            const skullPos = skullGeo.attributes.position;
            for (let i = 0; i < skullPos.count; i++) {
                const x = skullPos.getX(i);
                const y = skullPos.getY(i);
                const z = skullPos.getZ(i);

                let scale = 1.0;
                // Elongate Y
                skullPos.setY(i, y * 1.15);
                // Narrow sides
                skullPos.setX(i, x * 0.9);
                // Push face forward slightly
                if (z > 0) skullPos.setZ(i, z * 1.05);
            }

            headWireUniforms = {
                time: { value: 0 },
                opacity: { value: params.wireframeOpacity }
            };

            const wireMat = new THREE.ShaderMaterial({
                uniforms: headWireUniforms,
                vertexShader: `
                    varying vec3 vPos;
                    void main() {
                        vPos = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    varying vec3 vPos;
                    void main() {
                        float scanline = sin(vPos.y * 20.0 + time * 5.0) * 0.5 + 0.5;
                        vec3 color = vec3(0.0, 0.8, 1.0);
                        float alpha = opacity * (0.3 + scanline * 0.3);
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                wireframe: true,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const skullWire = new THREE.Mesh(skullGeo, wireMat);
            headGroup.add(skullWire);

            // Create glowing eyes
            createEyes();

            // Create animated mouth
            createMouth();

            headGroup.position.z = params.modelZ;
        }

        function createEyes() {
            const eyeGeometry = new THREE.SphereGeometry(1.2, 16, 16);

            const eyeMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    innerColor: { value: new THREE.Color(0xff0040) },
                    outerColor: { value: new THREE.Color(0x00ffff) }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 innerColor;
                    uniform vec3 outerColor;
                    varying vec3 vNormal;
                    varying vec3 vPosition;

                    void main() {
                        // Glowing eye effect
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                        vec3 color = mix(innerColor, outerColor, fresnel);

                        // Pulsing
                        float pulse = sin(time * 3.0) * 0.2 + 0.8;
                        color *= pulse;

                        // Inner glow
                        float center = 1.0 - length(vPosition.xy) * 0.5;
                        center = pow(max(center, 0.0), 2.0);

                        gl_FragColor = vec4(color * (0.5 + center), 0.9);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            // Left eye
            eyeLeftGroup = new THREE.Group();
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            eyeLeftGroup.add(leftEye);
            eyeLeftGroup.position.set(-2.5, 2, 6.5);
            headGroup.add(eyeLeftGroup);

            // Right eye
            eyeRightGroup = new THREE.Group();
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            eyeRightGroup.add(rightEye);
            eyeRightGroup.position.set(2.5, 2, 6.5);
            headGroup.add(eyeRightGroup);

            // Add pupil glow points
            const pupilGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const pupilMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });

            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.z = 0.9;
            eyeLeftGroup.add(leftPupil);

            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat.clone());
            rightPupil.position.z = 0.9;
            eyeRightGroup.add(rightPupil);

            // Create eyelids for blinking
            const eyelidGeometry = new THREE.PlaneGeometry(3, 1.5);
            const eyelidMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0x00ffff) },
                    opacity: { value: 0.9 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float opacity;
                    varying vec2 vUv;
                    void main() {
                        // Curved eyelid shape
                        float curve = 1.0 - pow(abs(vUv.x - 0.5) * 2.0, 2.0);
                        float edge = smoothstep(0.0, 0.3, vUv.y) * smoothstep(1.0, 0.7, vUv.y);
                        float alpha = curve * edge * opacity;
                        // Grid pattern
                        float grid = step(0.9, fract(vUv.x * 8.0)) + step(0.9, fract(vUv.y * 4.0));
                        vec3 finalColor = color * (0.3 + grid * 0.7);
                        gl_FragColor = vec4(finalColor, alpha * 0.95);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            // Left eyelid (upper)
            eyelidLeft = new THREE.Mesh(eyelidGeometry, eyelidMaterial.clone());
            eyelidLeft.position.set(0, 1.5, 1.3);
            eyelidLeft.rotation.x = Math.PI * 0.1;
            eyelidLeft.scale.y = 0; // Start open
            eyeLeftGroup.add(eyelidLeft);

            // Right eyelid (upper)
            eyelidRight = new THREE.Mesh(eyelidGeometry, eyelidMaterial.clone());
            eyelidRight.position.set(0, 1.5, 1.3);
            eyelidRight.rotation.x = Math.PI * 0.1;
            eyelidRight.scale.y = 0; // Start open
            eyeRightGroup.add(eyelidRight);
        }

        // Create animated mouth
        function createMouth() {
            mouthGroup = new THREE.Group();
            mouthGroup.position.set(0, -4, 6.5);
            headGroup.add(mouthGroup);

            // Outer mouth ring (lips)
            const lipGeometry = new THREE.TorusGeometry(1.2, 0.15, 8, 24);
            const lipMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xff0066) },
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vPos;
                    void main() {
                        vPos = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float time;
                    varying vec3 vPos;
                    void main() {
                        float glow = 0.6 + sin(time * 2.0) * 0.2;
                        gl_FragColor = vec4(color * glow, 0.9);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            const lips = new THREE.Mesh(lipGeometry, lipMaterial);
            lips.rotation.x = Math.PI / 2;
            lips.scale.set(1.5, 1, 0.3); // Flatten into mouth shape
            mouthGroup.add(lips);

            // Inner mouth (dark void that opens)
            const innerGeometry = new THREE.PlaneGeometry(2, 1);
            const innerMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    openness: { value: 0 },
                    color: { value: new THREE.Color(0x200010) }
                },
                vertexShader: `
                    uniform float openness;
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        vec3 pos = position;
                        // Scale based on openness
                        pos.y *= openness;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float openness;
                    varying vec2 vUv;
                    void main() {
                        // Dark interior with slight glow at edges
                        float edge = smoothstep(0.0, 0.3, vUv.x) * smoothstep(1.0, 0.7, vUv.x);
                        edge *= smoothstep(0.0, 0.2, vUv.y) * smoothstep(1.0, 0.8, vUv.y);
                        vec3 finalColor = mix(vec3(0.1, 0.0, 0.02), color, 1.0 - edge);
                        gl_FragColor = vec4(finalColor, openness * 0.95);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });

            mouthInner = new THREE.Mesh(innerGeometry, innerMaterial);
            mouthInner.position.z = 0.1;
            mouthGroup.add(mouthInner);

            // Add some "teeth" particles
            const teethGeometry = new THREE.BufferGeometry();
            const teethPositions = [];
            for (let i = 0; i < 20; i++) {
                const x = (Math.random() - 0.5) * 1.5;
                const y = (Math.random() - 0.5) * 0.3;
                const z = 0.05;
                teethPositions.push(x, y, z);
            }
            teethGeometry.setAttribute('position', new THREE.Float32BufferAttribute(teethPositions, 3));

            const teethMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.15,
                transparent: true,
                opacity: 0.8
            });

            const teeth = new THREE.Points(teethGeometry, teethMaterial);
            mouthGroup.add(teeth);
        }

        // Text-to-Speech functions
        function speak(text) {
            if (speechState.isSpeaking) {
                speechState.speechSynth.cancel();
            }

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.85;
            utterance.pitch = 0.7;
            utterance.volume = 1.0;

            // Try to get a deeper/creepier voice
            const voices = speechState.speechSynth.getVoices();
            const preferredVoice = voices.find(v =>
                v.name.includes('Male') ||
                v.name.includes('Daniel') ||
                v.name.includes('Google UK English Male')
            );
            if (preferredVoice) {
                utterance.voice = preferredVoice;
            }

            // Word boundary for mouth animation
            utterance.onboundary = (event) => {
                if (event.name === 'word') {
                    speechState.currentWord = text.substring(event.charIndex, event.charIndex + event.charLength);
                    // Open mouth based on word length/sounds
                    speechState.targetOpenness = 0.5 + Math.random() * 0.5;
                }
            };

            utterance.onstart = () => {
                speechState.isSpeaking = true;
                speechState.targetOpenness = 0.3;
            };

            utterance.onend = () => {
                speechState.isSpeaking = false;
                speechState.targetOpenness = 0;
                speechState.currentWord = '';
            };

            speechState.utterance = utterance;
            speechState.speechSynth.speak(utterance);
        }

        function speakRandom() {
            const phrase = creepyPhrases[Math.floor(Math.random() * creepyPhrases.length)];
            speak(phrase);
        }

        // Update mouth animation
        function updateMouth(time, delta) {
            if (!mouthInner) return;

            // Smooth mouth movement
            if (speechState.isSpeaking) {
                // Oscillate mouth while speaking for more natural look
                const speakOscillation = Math.sin(time * 15) * 0.2;
                speechState.targetOpenness = 0.4 + speakOscillation + Math.random() * 0.2;
            }

            // Lerp mouth openness
            speechState.mouthOpenness = THREE.MathUtils.lerp(
                speechState.mouthOpenness,
                speechState.targetOpenness,
                0.3
            );

            // Apply to mouth inner mesh
            mouthInner.material.uniforms.openness.value = speechState.mouthOpenness;
            mouthInner.scale.y = 0.1 + speechState.mouthOpenness * 1.5;

            // Animate lips slightly when speaking
            if (mouthGroup.children[0]) {
                mouthGroup.children[0].scale.y = 1 + speechState.mouthOpenness * 0.3;
                mouthGroup.children[0].material.uniforms.time.value = time;
            }
        }

        // Blink animation
        function updateBlink(time, delta) {
            // Check if it's time to blink
            if (!blinkState.isBlinking && time > blinkState.nextBlinkTime) {
                blinkState.isBlinking = true;
                blinkState.blinkProgress = 0;
            }

            if (blinkState.isBlinking) {
                blinkState.blinkProgress += delta / blinkState.blinkDuration;

                // Blink curve: quick close, quick open
                let lidPosition;
                if (blinkState.blinkProgress < 0.5) {
                    // Closing
                    lidPosition = Math.sin(blinkState.blinkProgress * Math.PI);
                } else {
                    // Opening
                    lidPosition = Math.sin(blinkState.blinkProgress * Math.PI);
                }

                // Apply to eyelids
                if (eyelidLeft && eyelidRight) {
                    eyelidLeft.scale.y = lidPosition;
                    eyelidRight.scale.y = lidPosition;
                    eyelidLeft.position.y = 1.5 - lidPosition * 0.8;
                    eyelidRight.position.y = 1.5 - lidPosition * 0.8;
                }

                // End blink
                if (blinkState.blinkProgress >= 1.0) {
                    blinkState.isBlinking = false;
                    blinkState.blinkProgress = 0;
                    // Random interval: 2-6 seconds, affected by blinkRate
                    blinkState.nextBlinkTime = time + (2 + Math.random() * 4) / params.blinkRate;

                    // Occasional double-blink
                    if (Math.random() < 0.2) {
                        blinkState.nextBlinkTime = time + 0.2;
                    }
                }
            }
        }

        createCyberpunkHead();

        // --- Controls ---
        function setupControls() {
            const gui = new dat.GUI();

            const folderHead = gui.addFolder('Head');
            folderHead.add(params, 'modelScale', 0.5, 2.0).name('Scale').onChange(v => {
                headGroup.scale.setScalar(v);
            });
            folderHead.add(params, 'modelZ', -50, 0).name('Depth').onChange(v => {
                headGroup.position.z = v;
            });
            folderHead.add(params, 'modelY', -10, 10).name('Height').onChange(v => {
                headGroup.position.y = v;
            });
            folderHead.open();

            const folderTracking = gui.addFolder('Tracking');
            folderTracking.add(params, 'headTrackStrength', 0, 2.0).name('Head Response');
            folderTracking.add(params, 'eyeTrackStrength', 0, 1.5).name('Eye Response');
            folderTracking.add(params, 'headTilt', 0, 1.0).name('Head Tilt');
            folderTracking.add(params, 'smoothing', 0.02, 0.2).name('Smoothing');
            folderTracking.add(params, 'showDebug').name('Show Webcam').onChange(val => {
                document.getElementById('debug-canvas').style.display = val ? 'block' : 'none';
            });
            folderTracking.open();

            const folderBehavior = gui.addFolder('Behavior');
            folderBehavior.add(params, 'blinkRate', 0.2, 3.0).name('Blink Rate');
            folderBehavior.add(params, 'idleMotion', 0, 1.5).name('Idle Motion');
            folderBehavior.open();

            const folderEnvironment = gui.addFolder('Tunnel');
            folderEnvironment.add(params, 'tunnelShift', 0, 2.0).name('Parallax Shift');
            folderEnvironment.add(params, 'tunnelTilt', 0, 1.5).name('Tunnel Tilt');
            folderEnvironment.open();

            const folderVisuals = gui.addFolder('Visuals');
            folderVisuals.add(params, 'glowIntensity', 0.5, 3.0).name('Glow');
            folderVisuals.add(params, 'particleSize', 1.0, 5.0).name('Particle Size');
            folderVisuals.add(params, 'wireframeOpacity', 0, 1.0).name('Wireframe');
            folderVisuals.add(params, 'pulseSpeed', 0, 3.0).name('Pulse Speed');
            folderVisuals.add(params, 'gridSpeed', 0, 5.0).name('Grid Speed');
        }

        setupControls();

        // --- Off-Axis Projection ---
        function updateCamera(head) {
            camera.position.copy(head);
            const dist = head.z;
            if (dist < 0.1) return;

            const halfW = SCREEN_WIDTH_CM / 2;
            const halfH = SCREEN_HEIGHT_CM / 2;
            const scale = NEAR / dist;

            camera.projectionMatrix.makePerspective(
                (-halfW - head.x) * scale,
                (halfW - head.x) * scale,
                (halfH - head.y) * scale,
                (-halfH - head.y) * scale,
                NEAR, FAR
            );
        }

        // --- Update Environment/Tunnel based on viewer position ---
        function updateEnvironment(time) {
            if (!environmentGroup) return;

            const viewerX = state.viewerPosition.x;
            const viewerY = state.viewerPosition.y;
            const viewerZ = state.viewerPosition.z;

            // Shift the tunnel slightly opposite to viewer movement
            // This creates the effect of "peering into" the tunnel
            const shiftX = -viewerX * params.tunnelShift * 0.05;
            const shiftY = -viewerY * params.tunnelShift * 0.05;

            // Tilt the tunnel based on viewer position
            // When viewer moves right, tunnel tilts slightly left (and vice versa)
            // This enhances the "looking down the corridor" feel
            const tiltY = -viewerX * params.tunnelTilt * 0.003;
            const tiltX = viewerY * params.tunnelTilt * 0.003;

            // Add subtle breathing/floating motion to the tunnel
            const breatheY = Math.sin(time * 0.3) * 0.1 * params.idleMotion;
            const breatheX = Math.sin(time * 0.2) * 0.05 * params.idleMotion;

            // Apply smooth interpolation
            environmentGroup.position.x = THREE.MathUtils.lerp(
                environmentGroup.position.x,
                shiftX + breatheX,
                params.smoothing * 0.5
            );
            environmentGroup.position.y = THREE.MathUtils.lerp(
                environmentGroup.position.y,
                shiftY + breatheY,
                params.smoothing * 0.5
            );

            // Apply tilt rotation
            environmentGroup.rotation.y = THREE.MathUtils.lerp(
                environmentGroup.rotation.y,
                tiltY,
                params.smoothing * 0.8
            );
            environmentGroup.rotation.x = THREE.MathUtils.lerp(
                environmentGroup.rotation.x,
                tiltX,
                params.smoothing * 0.8
            );

            // Subtle Z rotation for extra depth feel
            const tiltZ = viewerX * params.tunnelTilt * 0.001;
            environmentGroup.rotation.z = THREE.MathUtils.lerp(
                environmentGroup.rotation.z,
                tiltZ,
                params.smoothing * 0.5
            );
        }

        // --- Head Look-At with Idle Motion ---
        function updateHeadLookAt(time) {
            if (!headGroup) return;

            const viewerPos = state.viewerPosition.clone();
            const headPos = new THREE.Vector3();
            headGroup.getWorldPosition(headPos);
            const lookDir = viewerPos.clone().sub(headPos);

            // Calculate base angles for tracking
            const angleY = Math.atan2(lookDir.x, lookDir.z) * params.headTrackStrength;
            const angleX = Math.atan2(-lookDir.y, Math.sqrt(lookDir.x * lookDir.x + lookDir.z * lookDir.z)) * params.headTrackStrength;

            // Add head tilt (Z rotation) based on horizontal movement
            const angleZ = -angleY * params.headTilt * 0.3;

            // Add subtle idle motion (breathing, micro-movements)
            const idleY = Math.sin(time * 0.5) * 0.02 * params.idleMotion;
            const idleX = Math.sin(time * 0.3) * 0.015 * params.idleMotion;
            const idleZ = Math.sin(time * 0.7) * 0.01 * params.idleMotion;

            const maxRotY = Math.PI / 2.5;
            const maxRotX = Math.PI / 3;
            const maxRotZ = Math.PI / 8;

            const targetRotY = THREE.MathUtils.clamp(angleY + idleY, -maxRotY, maxRotY);
            const targetRotX = THREE.MathUtils.clamp(angleX + idleX, -maxRotX, maxRotX);
            const targetRotZ = THREE.MathUtils.clamp(angleZ + idleZ, -maxRotZ, maxRotZ);

            // Smooth rotation with all three axes
            headGroup.rotation.y = THREE.MathUtils.lerp(headGroup.rotation.y, targetRotY, params.smoothing * 1.5);
            headGroup.rotation.x = THREE.MathUtils.lerp(headGroup.rotation.x, targetRotX, params.smoothing * 1.5);
            headGroup.rotation.z = THREE.MathUtils.lerp(headGroup.rotation.z, targetRotZ, params.smoothing * 1.2);

            // Direct eye-to-eye contact tracking
            // Use the user's individual eye positions for more precise gaze
            if (eyeLeftGroup && eyeRightGroup) {
                // Calculate where each of the 3D head's eyes should look
                // to meet the user's eyes directly

                // User's left eye position in world space (relative to screen center)
                const userLeftEyeX = (0.5 - userEyes.left.x) * SCREEN_WIDTH_CM * 2.5;
                const userLeftEyeY = (0.5 - userEyes.left.y) * SCREEN_HEIGHT_CM * 2.0;

                // User's right eye position
                const userRightEyeX = (0.5 - userEyes.right.x) * SCREEN_WIDTH_CM * 2.5;
                const userRightEyeY = (0.5 - userEyes.right.y) * SCREEN_HEIGHT_CM * 2.0;

                // 3D head's left eye should look at user's right eye (mirror)
                // 3D head's right eye should look at user's left eye (mirror)
                const leftEyeLookX = userRightEyeX;
                const leftEyeLookY = userRightEyeY;
                const rightEyeLookX = userLeftEyeX;
                const rightEyeLookY = userLeftEyeY;

                // Calculate individual eye angles
                const eyeZ = state.viewerPosition.z;

                // Left eye of 3D head
                const leftAngleY = Math.atan2(leftEyeLookX - (-2.5 * params.modelScale), eyeZ) * params.eyeTrackStrength;
                const leftAngleX = Math.atan2(-leftEyeLookY, eyeZ) * params.eyeTrackStrength;

                // Right eye of 3D head
                const rightAngleY = Math.atan2(rightEyeLookX - (2.5 * params.modelScale), eyeZ) * params.eyeTrackStrength;
                const rightAngleX = Math.atan2(-rightEyeLookY, eyeZ) * params.eyeTrackStrength;

                const maxEyeRot = Math.PI / 4;

                // Apply to left eye
                const leftTargetY = THREE.MathUtils.clamp(leftAngleY, -maxEyeRot, maxEyeRot);
                const leftTargetX = THREE.MathUtils.clamp(leftAngleX, -maxEyeRot, maxEyeRot);

                // Apply to right eye
                const rightTargetY = THREE.MathUtils.clamp(rightAngleY, -maxEyeRot, maxEyeRot);
                const rightTargetX = THREE.MathUtils.clamp(rightAngleX, -maxEyeRot, maxEyeRot);

                // Faster, more responsive eye movement
                eyeLeftGroup.rotation.y = THREE.MathUtils.lerp(eyeLeftGroup.rotation.y, leftTargetY, params.smoothing * 3);
                eyeLeftGroup.rotation.x = THREE.MathUtils.lerp(eyeLeftGroup.rotation.x, leftTargetX, params.smoothing * 3);
                eyeRightGroup.rotation.y = THREE.MathUtils.lerp(eyeRightGroup.rotation.y, rightTargetY, params.smoothing * 3);
                eyeRightGroup.rotation.x = THREE.MathUtils.lerp(eyeRightGroup.rotation.x, rightTargetX, params.smoothing * 3);
            }
        }

        // --- Face Tracking ---
        async function startTracking() {
            try {
                const video = document.getElementById('debug-video');
                const canvas = document.getElementById('debug-canvas');
                const ctx = canvas.getContext('2d');

                const faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });

                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                faceMesh.onResults(results => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

                    if (results.multiFaceLandmarks.length > 0) {
                        state.trackingActive = true;
                        const lm = results.multiFaceLandmarks[0];
                        const lIris = lm[468], rIris = lm[473];

                        if (lIris && rIris) {
                            // Store individual eye positions for eye-to-eye contact
                            userEyes.left.set(lIris.x, lIris.y);
                            userEyes.right.set(rIris.x, rIris.y);
                            userEyes.centerX = (lIris.x + rIris.x) / 2;
                            userEyes.centerY = (lIris.y + rIris.y) / 2;

                            const cx = userEyes.centerX;
                            const cy = userEyes.centerY;

                            const dx = lIris.x - rIris.x;
                            const dy = lIris.y - rIris.y;
                            const dPx = Math.sqrt(dx * dx + dy * dy);

                            let z = 4.5 / dPx;
                            z = THREE.MathUtils.clamp(z, 15, 120);

                            const SENSITIVITY = 2.5;
                            const wx = (0.5 - cx) * SCREEN_WIDTH_CM * SENSITIVITY;
                            const wy = (0.5 - cy) * SCREEN_HEIGHT_CM * SENSITIVITY * 0.8;

                            state.targetHead.set(
                                THREE.MathUtils.clamp(wx, -50, 50),
                                THREE.MathUtils.clamp(wy, -50, 50),
                                z
                            );

                            // Debug viz - show both eyes being tracked
                            ctx.fillStyle = '#00ffff';
                            ctx.shadowColor = '#00ffff';
                            ctx.shadowBlur = 10;

                            // Left eye (user's)
                            ctx.beginPath();
                            ctx.arc(lIris.x * canvas.width, lIris.y * canvas.height, 3, 0, Math.PI * 2);
                            ctx.fill();

                            // Right eye (user's)
                            ctx.beginPath();
                            ctx.arc(rIris.x * canvas.width, rIris.y * canvas.height, 3, 0, Math.PI * 2);
                            ctx.fill();

                            // Center point
                            ctx.fillStyle = '#ff0080';
                            ctx.beginPath();
                            ctx.arc(cx * canvas.width, cy * canvas.height, 2, 0, Math.PI * 2);
                            ctx.fill();

                            // Draw connecting line between eyes
                            ctx.strokeStyle = '#00ffff';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(lIris.x * canvas.width, lIris.y * canvas.height);
                            ctx.lineTo(rIris.x * canvas.width, rIris.y * canvas.height);
                            ctx.stroke();

                            ctx.fillStyle = '#00ffff';
                            ctx.font = '10px Courier New';
                            ctx.fillText(`DIST: ${z.toFixed(0)}cm`, 5, 15);
                            ctx.fillText(`EYES LOCKED`, 5, 27);
                        }
                    }
                });

                const mediapipeCamera = new Camera(video, {
                    onFrame: async () => await faceMesh.send({ image: video }),
                    width: 640,
                    height: 480
                });

                await mediapipeCamera.start();
                document.getElementById('overlay').style.display = 'none';

            } catch (e) {
                console.error(e);
                document.getElementById('status').innerText = "ERROR: " + e.message;
            }
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('status').innerText = "INITIALIZING NEURAL LINK...";
            startTracking();
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update uniforms
            if (gridUniforms) gridUniforms.time.value = time * params.gridSpeed;
            if (headPointsUniforms) {
                headPointsUniforms.time.value = time * params.pulseSpeed;
                headPointsUniforms.glowIntensity.value = params.glowIntensity;
                headPointsUniforms.size.value = params.particleSize;
            }
            if (headWireUniforms) {
                headWireUniforms.time.value = time * params.pulseSpeed;
                headWireUniforms.opacity.value = params.wireframeOpacity;
            }

            // Update eye materials
            if (eyeLeftGroup && eyeLeftGroup.children[0]) {
                eyeLeftGroup.children[0].material.uniforms.time.value = time;
                eyeRightGroup.children[0].material.uniforms.time.value = time;
            }

            // Update blinking
            updateBlink(time, delta);

            // Update mouth animation
            updateMouth(time, delta);

            // Smooth tracking
            state.head.lerp(state.targetHead, params.smoothing);
            state.viewerPosition.copy(state.head);

            updateCamera(state.head);
            updateEnvironment(time);
            updateHeadLookAt(time);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(console.warn);
            } else {
                document.exitFullscreen();
            }
        });

        document.addEventListener('fullscreenchange', () => {
            document.getElementById('fullscreen-btn').textContent =
                document.fullscreenElement ? '[ EXIT ]' : '[ FULLSCREEN ]';
        });

        // --- Speech Controls ---
        document.getElementById('speak-btn').addEventListener('click', () => {
            const text = document.getElementById('speech-input').value.trim();
            if (text) {
                speak(text);
                document.getElementById('speech-input').value = '';
            }
        });

        document.getElementById('random-btn').addEventListener('click', () => {
            speakRandom();
        });

        document.getElementById('speech-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const text = e.target.value.trim();
                if (text) {
                    speak(text);
                    e.target.value = '';
                }
            }
        });

        // Pre-load voices
        if (speechState.speechSynth) {
            speechState.speechSynth.getVoices();
        }
    </script>
</body>

</html>
