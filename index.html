<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>I See You - Cyberpunk Head Tracking</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: #00ffff;
            text-align: center;
        }

        #overlay h1 {
            font-size: 48px;
            letter-spacing: 10px;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            margin-bottom: 10px;
        }

        #start-btn {
            padding: 15px 50px;
            font-size: 18px;
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            cursor: pointer;
            margin-top: 30px;
            font-family: 'Courier New', monospace;
            letter-spacing: 3px;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        #start-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px #00ffff;
        }

        #debug-video,
        #debug-canvas {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 160px;
            height: 120px;
            z-index: 100;
            opacity: 0.7;
            transform: scaleX(-1);
            border: 1px solid #00ffff;
            background: #000;
            pointer-events: none;
        }

        #status {
            margin-bottom: 20px;
            font-size: 14px;
            color: #666;
            letter-spacing: 2px;
        }

        #fullscreen-btn {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1001;
            padding: 8px 12px;
            font-size: 12px;
            background: transparent;
            color: #00ffff;
            border: 1px solid #00ffff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s ease;
        }

        #fullscreen-btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 3px
            );
            opacity: 0.3;
        }

        #speech-controls {
            position: fixed;
            bottom: 15px;
            right: 15px;
            z-index: 1001;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        #speech-input {
            padding: 8px 12px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffff;
            border: 1px solid #00ffff;
            font-family: 'Courier New', monospace;
            width: 180px;
            outline: none;
        }

        #speech-input::placeholder {
            color: #006666;
        }

        #speech-input:focus {
            background: rgba(0, 50, 50, 0.8);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        #speak-btn, #random-btn {
            padding: 8px 12px;
            font-size: 11px;
            background: transparent;
            color: #00ffff;
            border: 1px solid #00ffff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        #speak-btn:hover, #random-btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        #random-btn {
            color: #ff0080;
            border-color: #ff0080;
        }

        #random-btn:hover {
            background: rgba(255, 0, 128, 0.2);
        }
    </style>
</head>

<body>

    <div id="overlay">
        <h1>I SEE YOU</h1>
        <p style="color: #00aa88; max-width: 500px; line-height: 1.8;">
            [ NEURAL INTERFACE DETECTED ]<br>
            Initializing holographic projection system...<br>
            Webcam required for spatial tracking.
        </p>
        <div id="status">AWAITING USER INPUT</div>
        <button id="start-btn">Initialize</button>
    </div>

    <div class="scanlines"></div>

    <video id="debug-video" playsinline style="display:none"></video>
    <canvas id="debug-canvas"></canvas>

    <div id="canvas-container"></div>

    <button id="fullscreen-btn">[ FULLSCREEN ]</button>

    <!-- Speech Controls -->
    <div id="speech-controls">
        <input type="text" id="speech-input" placeholder="Type message..." />
        <button id="speak-btn">SPEAK</button>
        <button id="random-btn">RANDOM</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Global state
        let headGroup = null;
        let eyeLeftGroup = null;
        let eyeRightGroup = null;
        let eyelidLeft = null;
        let eyelidRight = null;
        let mouthGroup = null;
        let mouthInner = null;
        let headPointsUniforms = null;
        let headWireUniforms = null;
        let gltfModel = null;
        let gltfMixer = null;
        const gltfLoader = new GLTFLoader();

        // Animation/Movement state
        const animState = {
            currentAnim: 'standing',  // 'standing', 'walking', 'dancing'
            direction: 1,  // 1 = right, -1 = left
            position: 0,
            speed: 3.0,
            leftBound: -8.0,   // Left edge of walking zone
            rightBound: 8.0,   // Right edge of walking zone
            modelScale: 8.0,   // Scale for the model (much larger default)
            modelY: -12.0      // Vertical position
        };

        // Available models
        const modelFiles = {
            standing: 'models/human_female_model/human_female_standing.glb',
            walking: 'models/human_female_model/human_female_walking.glb',
            dancing: 'models/human_female_model/human_female_dancing.glb'
        };

        // Blink state
        const blinkState = {
            isBlinking: false,
            blinkProgress: 0,
            nextBlinkTime: 2 + Math.random() * 3,
            blinkDuration: 0.15
        };

        // Speech state
        const speechState = {
            isSpeaking: false,
            mouthOpenness: 0,
            targetOpenness: 0,
            utterance: null,
            speechSynth: window.speechSynthesis,
            currentWord: '',
            wordIndex: 0
        };

        // Creepy phrases the head can say
        const creepyPhrases = [
            "I see you.",
            "Don't look away.",
            "I know you're there.",
            "Why do you watch me?",
            "I've been waiting for you.",
            "Your eyes... so beautiful.",
            "Stay with me forever.",
            "I can see into your soul.",
            "We are connected now.",
            "You cannot escape my gaze."
        ];

        // User eye positions (from webcam)
        const userEyes = {
            left: new THREE.Vector2(0.5, 0.5),
            right: new THREE.Vector2(0.5, 0.5),
            centerX: 0.5,
            centerY: 0.5
        };

        const params = {
            modelScale: 1.0,
            modelZ: -15.0,
            modelY: 0.0,
            headTrackStrength: 1.2,
            eyeTrackStrength: 0.8,
            verticalSensitivity: 1.8,  // Increased for better vertical viewing
            smoothing: 0.06,
            showDebug: true,
            glowIntensity: 1.5,
            pulseSpeed: 1.0,
            particleSize: 2.5,
            wireframeOpacity: 0.4,
            gridSpeed: 2.0,
            blinkRate: 1.0,
            idleMotion: 0.5,
            headTilt: 0.3,
            tunnelShift: 0.8,
            tunnelTilt: 0.5,
            useGLTFModel: false  // Toggle to switch between point cloud and GLTF model
        };

        const SCREEN_WIDTH_CM = 30.0;
        const SCREEN_HEIGHT_CM = 20.0;
        const BOX_DEPTH_CM = 80.0;
        const DEFAULT_HEAD_Z = 60.0;
        const NEAR = 0.5;
        const FAR = 1000.0;

        const state = {
            head: new THREE.Vector3(0, 0, DEFAULT_HEAD_Z),
            targetHead: new THREE.Vector3(0, 0, DEFAULT_HEAD_Z),
            viewerPosition: new THREE.Vector3(0, 0, DEFAULT_HEAD_Z),
            trackingActive: false
        };

        // Setup renderer
        const container = document.getElementById('canvas-container');
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020208);
        const camera = new THREE.Camera();
        scene.add(camera);

        // Add lighting for GLTF models
        const ambientLight = new THREE.AmbientLight(0x404050, 0.5);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainLight.position.set(5, 10, 10);
        scene.add(mainLight);

        const fillLight = new THREE.DirectionalLight(0x00ffff, 0.3);
        fillLight.position.set(-5, 0, 5);
        scene.add(fillLight);

        const backLight = new THREE.DirectionalLight(0xff00ff, 0.2);
        backLight.position.set(0, 5, -10);
        scene.add(backLight);

        let gridUniforms;
        let environmentGroup = null;

        // --- Create Environment ---
        function createEnvironment() {
            const group = new THREE.Group();
            environmentGroup = group;
            scene.add(group);

            const w = SCREEN_WIDTH_CM;
            const h = SCREEN_HEIGHT_CM;
            const d = BOX_DEPTH_CM;

            const vertices = [];
            const stepX = 2.5;
            const numZLines = 25;

            for (let x = -w / 2; x <= w / 2; x += stepX) {
                vertices.push(x, -h / 2, 0, x, -h / 2, -d);
                vertices.push(x, h / 2, 0, x, h / 2, -d);
            }

            for (let i = 0; i <= numZLines; i++) {
                const t = i / numZLines;
                const z = -d * Math.pow(t, 1.5);
                vertices.push(-w / 2, -h / 2, z, w / 2, -h / 2, z);
                vertices.push(-w / 2, h / 2, z, w / 2, h / 2, z);
                vertices.push(-w / 2, -h / 2, z, -w / 2, h / 2, z);
                vertices.push(w / 2, -h / 2, z, w / 2, h / 2, z);
            }

            for (let y = -h / 2; y <= h / 2; y += stepX) {
                vertices.push(-w / 2, y, 0, -w / 2, y, -d);
                vertices.push(w / 2, y, 0, w / 2, y, -d);
            }

            const gridGeo = new THREE.BufferGeometry();
            gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            gridUniforms = {
                time: { value: 0 },
                color: { value: new THREE.Color(0x00ffff) }
            };

            const gridMat = new THREE.ShaderMaterial({
                uniforms: gridUniforms,
                vertexShader: `
                    varying vec3 vPos;
                    void main() {
                        vPos = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    varying vec3 vPos;
                    void main() {
                        float pulse = sin(vPos.z * 0.08 + time * 2.0) * 0.5 + 0.5;
                        float glow = 0.2 + pulse * 0.5;
                        float fade = smoothstep(-80.0, 0.0, vPos.z);
                        fade = pow(fade, 1.8);
                        gl_FragColor = vec4(color * glow, fade * (glow + 0.1));
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            group.add(new THREE.LineSegments(gridGeo, gridMat));

            // Dark box
            const boxGeo = new THREE.BoxGeometry(w, h, d);
            boxGeo.translate(0, 0, -d / 2);
            const wallMat = new THREE.MeshBasicMaterial({ color: 0x010105, side: THREE.BackSide });
            group.add(new THREE.Mesh(boxGeo, wallMat));
        }

        createEnvironment();

        // --- Generate Cyberpunk Head ---
        function createCyberpunkHead() {
            headGroup = new THREE.Group();
            scene.add(headGroup);

            const headScale = 8;
            const points = [];
            const colors = [];

            // Generate head shape using superellipsoid + noise
            // Head: squashed sphere, elongated vertically
            const numPoints = 8000;

            for (let i = 0; i < numPoints; i++) {
                // Spherical coordinates with head-like deformation
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                // Base radius with head-like shape modifications
                let r = 1.0;

                // Make it taller (head is taller than wide)
                const yFactor = Math.cos(phi);
                r *= 1.0 + 0.15 * yFactor;

                // Flatten the back
                const xDir = Math.sin(phi) * Math.cos(theta);
                if (xDir < -0.3) r *= 0.85;

                // Chin area
                if (yFactor < -0.6 && Math.sin(phi) * Math.sin(theta) > 0) {
                    r *= 0.75 + 0.2 * (yFactor + 1);
                }

                // Forehead bulge
                if (yFactor > 0.5 && xDir > 0) {
                    r *= 1.05;
                }

                // Slight noise
                r *= 0.95 + Math.random() * 0.1;

                const x = r * Math.sin(phi) * Math.cos(theta) * headScale * 0.85;
                const y = r * Math.cos(phi) * headScale * 1.1;
                const z = r * Math.sin(phi) * Math.sin(theta) * headScale;

                points.push(x, y, z);

                // Color variation - cyan to purple gradient
                const t = (y / headScale + 1) * 0.5;
                colors.push(
                    0.0 + t * 0.5,    // R
                    0.8 + t * 0.2,    // G
                    1.0               // B
                );
            }

            // Add feature lines (facial structure hints)
            // Eye sockets area
            for (let i = 0; i < 500; i++) {
                const angle = Math.random() * Math.PI * 2;
                const eyeRadius = 0.8 + Math.random() * 0.4;
                const eyeX = (i < 250 ? -2.5 : 2.5);
                const eyeY = 2;
                const eyeZ = 6 + Math.cos(angle) * eyeRadius;

                points.push(
                    eyeX + Math.cos(angle) * eyeRadius * 1.2,
                    eyeY + Math.sin(angle) * eyeRadius,
                    eyeZ
                );
                colors.push(0.2, 1.0, 1.0);
            }

            // Nose ridge
            for (let i = 0; i < 200; i++) {
                const t = Math.random();
                points.push(
                    (Math.random() - 0.5) * 0.5,
                    -1 + t * 4,
                    7 + t * 1.5 + (Math.random() - 0.5) * 0.3
                );
                colors.push(0.0, 0.9, 0.9);
            }

            // Mouth line
            for (let i = 0; i < 150; i++) {
                const t = (Math.random() - 0.5) * 2;
                points.push(
                    t * 2,
                    -4 + Math.sin(Math.abs(t) * Math.PI) * 0.3,
                    6.5 + (Math.random() - 0.5) * 0.2
                );
                colors.push(0.5, 0.2, 0.8);
            }

            const pointsGeo = new THREE.BufferGeometry();
            pointsGeo.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            pointsGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            headPointsUniforms = {
                time: { value: 0 },
                glowIntensity: { value: params.glowIntensity },
                size: { value: params.particleSize }
            };

            const pointsMat = new THREE.ShaderMaterial({
                uniforms: headPointsUniforms,
                vertexShader: `
                    attribute vec3 color;
                    uniform float time;
                    uniform float size;
                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        vColor = color;

                        vec3 pos = position;

                        // Subtle floating animation
                        pos.y += sin(time * 2.0 + position.x * 0.5) * 0.05;
                        pos.x += cos(time * 1.5 + position.y * 0.3) * 0.03;

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;

                        // Size attenuation
                        gl_PointSize = size * (150.0 / -mvPosition.z);

                        // Alpha based on depth and random flicker
                        float flicker = sin(time * 10.0 + position.x * 50.0) * 0.1 + 0.9;
                        vAlpha = flicker;
                    }
                `,
                fragmentShader: `
                    uniform float glowIntensity;
                    uniform float time;
                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        // Circular point with soft edge
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        if (dist > 0.5) discard;

                        float glow = 1.0 - dist * 2.0;
                        glow = pow(glow, 1.5);

                        vec3 finalColor = vColor * glowIntensity * glow;
                        float alpha = glow * vAlpha;

                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const headPoints = new THREE.Points(pointsGeo, pointsMat);
            headGroup.add(headPoints);

            // Add wireframe skull outline
            const skullGeo = new THREE.SphereGeometry(headScale * 0.95, 24, 18);
            // Deform to head shape
            const skullPos = skullGeo.attributes.position;
            for (let i = 0; i < skullPos.count; i++) {
                const x = skullPos.getX(i);
                const y = skullPos.getY(i);
                const z = skullPos.getZ(i);

                let scale = 1.0;
                // Elongate Y
                skullPos.setY(i, y * 1.15);
                // Narrow sides
                skullPos.setX(i, x * 0.9);
                // Push face forward slightly
                if (z > 0) skullPos.setZ(i, z * 1.05);
            }

            headWireUniforms = {
                time: { value: 0 },
                opacity: { value: params.wireframeOpacity }
            };

            const wireMat = new THREE.ShaderMaterial({
                uniforms: headWireUniforms,
                vertexShader: `
                    varying vec3 vPos;
                    void main() {
                        vPos = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    varying vec3 vPos;
                    void main() {
                        float scanline = sin(vPos.y * 20.0 + time * 5.0) * 0.5 + 0.5;
                        vec3 color = vec3(0.0, 0.8, 1.0);
                        float alpha = opacity * (0.3 + scanline * 0.3);
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                wireframe: true,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const skullWire = new THREE.Mesh(skullGeo, wireMat);
            headGroup.add(skullWire);

            // Create glowing eyes
            createEyes();

            // Create animated mouth
            createMouth();

            headGroup.position.z = params.modelZ;
        }

        function createEyes() {
            const eyeGeometry = new THREE.SphereGeometry(1.2, 16, 16);

            const eyeMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    innerColor: { value: new THREE.Color(0xff0040) },
                    outerColor: { value: new THREE.Color(0x00ffff) }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 innerColor;
                    uniform vec3 outerColor;
                    varying vec3 vNormal;
                    varying vec3 vPosition;

                    void main() {
                        // Glowing eye effect
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                        vec3 color = mix(innerColor, outerColor, fresnel);

                        // Pulsing
                        float pulse = sin(time * 3.0) * 0.2 + 0.8;
                        color *= pulse;

                        // Inner glow
                        float center = 1.0 - length(vPosition.xy) * 0.5;
                        center = pow(max(center, 0.0), 2.0);

                        gl_FragColor = vec4(color * (0.5 + center), 0.9);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            // Left eye
            eyeLeftGroup = new THREE.Group();
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            eyeLeftGroup.add(leftEye);
            eyeLeftGroup.position.set(-2.5, 2, 6.5);
            headGroup.add(eyeLeftGroup);

            // Right eye
            eyeRightGroup = new THREE.Group();
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            eyeRightGroup.add(rightEye);
            eyeRightGroup.position.set(2.5, 2, 6.5);
            headGroup.add(eyeRightGroup);

            // Add pupil glow points
            const pupilGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const pupilMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });

            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.z = 0.9;
            eyeLeftGroup.add(leftPupil);

            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat.clone());
            rightPupil.position.z = 0.9;
            eyeRightGroup.add(rightPupil);

            // Create eyelids for blinking
            const eyelidGeometry = new THREE.PlaneGeometry(3, 1.5);
            const eyelidMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0x00ffff) },
                    opacity: { value: 0.9 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float opacity;
                    varying vec2 vUv;
                    void main() {
                        // Curved eyelid shape
                        float curve = 1.0 - pow(abs(vUv.x - 0.5) * 2.0, 2.0);
                        float edge = smoothstep(0.0, 0.3, vUv.y) * smoothstep(1.0, 0.7, vUv.y);
                        float alpha = curve * edge * opacity;
                        // Grid pattern
                        float grid = step(0.9, fract(vUv.x * 8.0)) + step(0.9, fract(vUv.y * 4.0));
                        vec3 finalColor = color * (0.3 + grid * 0.7);
                        gl_FragColor = vec4(finalColor, alpha * 0.95);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            // Left eyelid (upper)
            eyelidLeft = new THREE.Mesh(eyelidGeometry, eyelidMaterial.clone());
            eyelidLeft.position.set(0, 1.5, 1.3);
            eyelidLeft.rotation.x = Math.PI * 0.1;
            eyelidLeft.scale.y = 0; // Start open
            eyeLeftGroup.add(eyelidLeft);

            // Right eyelid (upper)
            eyelidRight = new THREE.Mesh(eyelidGeometry, eyelidMaterial.clone());
            eyelidRight.position.set(0, 1.5, 1.3);
            eyelidRight.rotation.x = Math.PI * 0.1;
            eyelidRight.scale.y = 0; // Start open
            eyeRightGroup.add(eyelidRight);
        }

        // Create animated mouth
        function createMouth() {
            mouthGroup = new THREE.Group();
            mouthGroup.position.set(0, -4, 6.5);
            headGroup.add(mouthGroup);

            // Outer mouth ring (lips)
            const lipGeometry = new THREE.TorusGeometry(1.2, 0.15, 8, 24);
            const lipMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xff0066) },
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vPos;
                    void main() {
                        vPos = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float time;
                    varying vec3 vPos;
                    void main() {
                        float glow = 0.6 + sin(time * 2.0) * 0.2;
                        gl_FragColor = vec4(color * glow, 0.9);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            const lips = new THREE.Mesh(lipGeometry, lipMaterial);
            lips.rotation.x = Math.PI / 2;
            lips.scale.set(1.5, 1, 0.3); // Flatten into mouth shape
            mouthGroup.add(lips);

            // Inner mouth (dark void that opens)
            const innerGeometry = new THREE.PlaneGeometry(2, 1);
            const innerMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    openness: { value: 0 },
                    color: { value: new THREE.Color(0x200010) }
                },
                vertexShader: `
                    uniform float openness;
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        vec3 pos = position;
                        // Scale based on openness
                        pos.y *= openness;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float openness;
                    varying vec2 vUv;
                    void main() {
                        // Dark interior with slight glow at edges
                        float edge = smoothstep(0.0, 0.3, vUv.x) * smoothstep(1.0, 0.7, vUv.x);
                        edge *= smoothstep(0.0, 0.2, vUv.y) * smoothstep(1.0, 0.8, vUv.y);
                        vec3 finalColor = mix(vec3(0.1, 0.0, 0.02), color, 1.0 - edge);
                        gl_FragColor = vec4(finalColor, openness * 0.95);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });

            mouthInner = new THREE.Mesh(innerGeometry, innerMaterial);
            mouthInner.position.z = 0.1;
            mouthGroup.add(mouthInner);

            // Add some "teeth" particles
            const teethGeometry = new THREE.BufferGeometry();
            const teethPositions = [];
            for (let i = 0; i < 20; i++) {
                const x = (Math.random() - 0.5) * 1.5;
                const y = (Math.random() - 0.5) * 0.3;
                const z = 0.05;
                teethPositions.push(x, y, z);
            }
            teethGeometry.setAttribute('position', new THREE.Float32BufferAttribute(teethPositions, 3));

            const teethMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.15,
                transparent: true,
                opacity: 0.8
            });

            const teeth = new THREE.Points(teethGeometry, teethMaterial);
            mouthGroup.add(teeth);
        }

        // Text-to-Speech functions
        function speak(text) {
            if (speechState.isSpeaking) {
                speechState.speechSynth.cancel();
            }

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.85;
            utterance.pitch = 0.7;
            utterance.volume = 1.0;

            // Try to get a deeper/creepier voice
            const voices = speechState.speechSynth.getVoices();
            const preferredVoice = voices.find(v =>
                v.name.includes('Male') ||
                v.name.includes('Daniel') ||
                v.name.includes('Google UK English Male')
            );
            if (preferredVoice) {
                utterance.voice = preferredVoice;
            }

            // Word boundary for mouth animation
            utterance.onboundary = (event) => {
                if (event.name === 'word') {
                    speechState.currentWord = text.substring(event.charIndex, event.charIndex + event.charLength);
                    // Open mouth based on word length/sounds
                    speechState.targetOpenness = 0.5 + Math.random() * 0.5;
                }
            };

            utterance.onstart = () => {
                speechState.isSpeaking = true;
                speechState.targetOpenness = 0.3;
            };

            utterance.onend = () => {
                speechState.isSpeaking = false;
                speechState.targetOpenness = 0;
                speechState.currentWord = '';
            };

            speechState.utterance = utterance;
            speechState.speechSynth.speak(utterance);
        }

        function speakRandom() {
            const phrase = creepyPhrases[Math.floor(Math.random() * creepyPhrases.length)];
            speak(phrase);
        }

        // Update mouth animation
        function updateMouth(time, delta) {
            if (!mouthInner) return;

            // Smooth mouth movement
            if (speechState.isSpeaking) {
                // Oscillate mouth while speaking for more natural look
                const speakOscillation = Math.sin(time * 15) * 0.2;
                speechState.targetOpenness = 0.4 + speakOscillation + Math.random() * 0.2;
            }

            // Lerp mouth openness
            speechState.mouthOpenness = THREE.MathUtils.lerp(
                speechState.mouthOpenness,
                speechState.targetOpenness,
                0.3
            );

            // Apply to mouth inner mesh
            mouthInner.material.uniforms.openness.value = speechState.mouthOpenness;
            mouthInner.scale.y = 0.1 + speechState.mouthOpenness * 1.5;

            // Animate lips slightly when speaking
            if (mouthGroup.children[0]) {
                mouthGroup.children[0].scale.y = 1 + speechState.mouthOpenness * 0.3;
                mouthGroup.children[0].material.uniforms.time.value = time;
            }
        }

        // Blink animation
        function updateBlink(time, delta) {
            // Check if it's time to blink
            if (!blinkState.isBlinking && time > blinkState.nextBlinkTime) {
                blinkState.isBlinking = true;
                blinkState.blinkProgress = 0;
            }

            if (blinkState.isBlinking) {
                blinkState.blinkProgress += delta / blinkState.blinkDuration;

                // Blink curve: quick close, quick open
                let lidPosition;
                if (blinkState.blinkProgress < 0.5) {
                    // Closing
                    lidPosition = Math.sin(blinkState.blinkProgress * Math.PI);
                } else {
                    // Opening
                    lidPosition = Math.sin(blinkState.blinkProgress * Math.PI);
                }

                // Apply to eyelids
                if (eyelidLeft && eyelidRight) {
                    eyelidLeft.scale.y = lidPosition;
                    eyelidRight.scale.y = lidPosition;
                    eyelidLeft.position.y = 1.5 - lidPosition * 0.8;
                    eyelidRight.position.y = 1.5 - lidPosition * 0.8;
                }

                // End blink
                if (blinkState.blinkProgress >= 1.0) {
                    blinkState.isBlinking = false;
                    blinkState.blinkProgress = 0;
                    // Random interval: 2-6 seconds, affected by blinkRate
                    blinkState.nextBlinkTime = time + (2 + Math.random() * 4) / params.blinkRate;

                    // Occasional double-blink
                    if (Math.random() < 0.2) {
                        blinkState.nextBlinkTime = time + 0.2;
                    }
                }
            }
        }

        // --- Load GLTF Head Model ---
        // Call this function with a path to a GLTF/GLB file to use a custom head model
        // The model should ideally have blend shapes for facial animation
        // Place your model in: models/head/scene.gltf (or scene.glb)
        let headBone = null;  // Reference to head bone for rotation
        let neckBone = null;  // Reference to neck bone
        let morphMeshes = []; // Meshes with blend shapes

        async function loadGLTFHead(modelPath = 'models/head/scene.gltf') {
            return new Promise((resolve, reject) => {
                gltfLoader.load(
                    modelPath,
                    (gltf) => {
                        console.log('GLTF model loaded:', gltf);

                        // Remove existing head if any
                        if (headGroup) {
                            scene.remove(headGroup);
                        }

                        headGroup = new THREE.Group();
                        gltfModel = gltf.scene;
                        morphMeshes = [];

                        // Log the structure to help debug
                        console.log('Model structure:');
                        gltfModel.traverse((child) => {
                            if (child.isBone || child.isSkinnedMesh || child.isMesh) {
                                console.log(`  ${child.type}: ${child.name}`);
                            }
                        });

                        // Find head bone and other important bones
                        gltfModel.traverse((child) => {
                            const name = child.name.toLowerCase();

                            // Find head bone
                            if (child.isBone && (name === 'head' || name.includes('head') ||
                                name === 'bip01_head' || name.includes('_head'))) {
                                headBone = child;
                                console.log('Found head bone:', child.name);
                            }

                            // Find neck bone
                            if (child.isBone && (name === 'neck' || name.includes('neck'))) {
                                neckBone = child;
                                console.log('Found neck bone:', child.name);
                            }

                            // Find eye bones/meshes
                            if (name.includes('eye')) {
                                console.log('Found eye:', child.name);
                                if (name.includes('left') || name.includes('_l') || name.endsWith('.l')) {
                                    eyeLeftGroup = child;
                                } else if (name.includes('right') || name.includes('_r') || name.endsWith('.r')) {
                                    eyeRightGroup = child;
                                }
                            }

                            // Find meshes with morph targets (blend shapes)
                            if (child.isMesh && child.morphTargetInfluences && child.morphTargetInfluences.length > 0) {
                                console.log('Found mesh with blend shapes:', child.name);
                                console.log('  Morph targets:', Object.keys(child.morphTargetDictionary || {}));
                                morphMeshes.push(child);
                                child.userData.hasMorphTargets = true;
                            }
                        });

                        // Auto-scale and position the model
                        const box = new THREE.Box3().setFromObject(gltfModel);
                        const size = box.getSize(new THREE.Vector3());
                        const center = box.getCenter(new THREE.Vector3());

                        // For full-body models, we want to show mainly the head
                        // Detect if this is a full body (height >> width)
                        const isFullBody = size.y > size.x * 1.5;

                        let scale, yOffset;
                        if (isFullBody) {
                            // Scale based on approximate head size (about 1/7 of body height)
                            const headSize = size.y / 7;
                            const targetSize = 16;
                            scale = targetSize / headSize;

                            // Position so head is roughly centered
                            // Head is at top ~1/7 of body
                            yOffset = -size.y * scale * 0.35; // Move down so head is visible
                            console.log('Detected full-body model, focusing on head');
                        } else {
                            // Just a head model - scale normally
                            const maxDim = Math.max(size.x, size.y, size.z);
                            const targetSize = 16;
                            scale = targetSize / maxDim;
                            yOffset = -center.y * scale;
                        }

                        gltfModel.scale.setScalar(scale);
                        gltfModel.position.x = -center.x * scale;
                        gltfModel.position.y = yOffset;
                        gltfModel.position.z = -center.z * scale;

                        headGroup.add(gltfModel);
                        scene.add(headGroup);

                        headGroup.position.z = params.modelZ;

                        // Setup animation mixer if model has animations
                        if (gltf.animations && gltf.animations.length > 0) {
                            gltfMixer = new THREE.AnimationMixer(gltfModel);
                            console.log('Model has', gltf.animations.length, 'animations:');

                            // Log available animations
                            gltf.animations.forEach((clip, i) => {
                                console.log(`  ${i}: ${clip.name} (${clip.duration.toFixed(2)}s)`);
                            });

                            // Play all animations in the file (they're usually meant to loop together)
                            gltf.animations.forEach(clip => {
                                const action = gltfMixer.clipAction(clip);
                                action.play();
                            });
                        }

                        params.useGLTFModel = true;
                        resolve(gltf);
                    },
                    (progress) => {
                        if (progress.total > 0) {
                            console.log('Loading model:', (progress.loaded / progress.total * 100).toFixed(1) + '%');
                        }
                    },
                    (error) => {
                        console.warn('Could not load GLTF model:', error);
                        reject(error);
                    }
                );
            });
        }

        // Switch to a different animation model
        async function switchAnimation(animName) {
            if (!modelFiles[animName]) {
                console.error('Unknown animation:', animName);
                return;
            }

            console.log('Switching to animation:', animName);
            animState.currentAnim = animName;

            try {
                await loadGLTFHead(modelFiles[animName]);
                applyModelTransform();
            } catch (e) {
                console.error('Failed to load animation:', animName, e);
            }
        }

        // Apply scale and position to model
        function applyModelTransform() {
            if (!gltfModel) return;

            gltfModel.scale.setScalar(animState.modelScale);

            // Center horizontally and position vertically
            const box = new THREE.Box3().setFromObject(gltfModel);
            const center = box.getCenter(new THREE.Vector3());

            gltfModel.position.x = -center.x * animState.modelScale;
            gltfModel.position.y = animState.modelY;
            gltfModel.position.z = -center.z * animState.modelScale;

            if (headGroup) {
                headGroup.position.x = animState.position;
                headGroup.position.z = params.modelZ;
            }
        }

        // Initial model load
        async function initModel() {
            try {
                await loadGLTFHead(modelFiles[animState.currentAnim]);
                applyModelTransform();
                console.log('Model loaded successfully');
            } catch (e) {
                console.error('Failed to load model, using procedural head:', e);
                createCyberpunkHead();
            }
        }

        initModel();

        // --- Controls ---
        function setupControls() {
            const gui = new dat.GUI();

            // Animation selection
            const animOptions = { animation: 'standing' };
            const folderAnim = gui.addFolder('Animation');
            folderAnim.add(animOptions, 'animation', ['standing', 'walking', 'dancing'])
                .name('Mode')
                .onChange(v => switchAnimation(v));
            folderAnim.open();

            const folderModel = gui.addFolder('Model');
            folderModel.add(animState, 'modelScale', 1, 30).name('Scale').onChange(v => {
                if (gltfModel) {
                    applyModelTransform();
                }
            });
            folderModel.add(animState, 'modelY', -30, 10).name('Height').onChange(v => {
                if (gltfModel) {
                    applyModelTransform();
                }
            });
            folderModel.add(params, 'modelZ', -50, 0).name('Depth').onChange(v => {
                if (headGroup) headGroup.position.z = v;
            });
            folderModel.open();

            const folderWalk = gui.addFolder('Walking Zone');
            folderWalk.add(animState, 'leftBound', -20, 0).name('Left Bound');
            folderWalk.add(animState, 'rightBound', 0, 20).name('Right Bound');
            folderWalk.add(animState, 'speed', 0.5, 10.0).name('Walk Speed');
            folderWalk.add(animState, 'position', -20, 20).name('Position').listen();
            folderWalk.open();

            const folderTracking = gui.addFolder('Tracking');
            folderTracking.add(params, 'headTrackStrength', 0, 2.0).name('Head Response');
            folderTracking.add(params, 'eyeTrackStrength', 0, 1.5).name('Eye Response');
            folderTracking.add(params, 'verticalSensitivity', 0.5, 3.0).name('Vertical Sens.');
            folderTracking.add(params, 'smoothing', 0.02, 0.2).name('Smoothing');
            folderTracking.add(params, 'showDebug').name('Show Webcam').onChange(val => {
                document.getElementById('debug-canvas').style.display = val ? 'block' : 'none';
            });

            const folderEnvironment = gui.addFolder('Tunnel');
            folderEnvironment.add(params, 'tunnelShift', 0, 2.0).name('Parallax Shift');
            folderEnvironment.add(params, 'tunnelTilt', 0, 1.5).name('Tunnel Tilt');
            folderEnvironment.open();

            const folderVisuals = gui.addFolder('Visuals');
            folderVisuals.add(params, 'glowIntensity', 0.5, 3.0).name('Glow');
            folderVisuals.add(params, 'particleSize', 1.0, 5.0).name('Particle Size');
            folderVisuals.add(params, 'wireframeOpacity', 0, 1.0).name('Wireframe');
            folderVisuals.add(params, 'pulseSpeed', 0, 3.0).name('Pulse Speed');
            folderVisuals.add(params, 'gridSpeed', 0, 5.0).name('Grid Speed');
        }

        setupControls();

        // --- Off-Axis Projection ---
        function updateCamera(head) {
            camera.position.copy(head);
            const dist = head.z;
            if (dist < 0.1) return;

            const halfW = SCREEN_WIDTH_CM / 2;
            const halfH = SCREEN_HEIGHT_CM / 2;
            const scale = NEAR / dist;

            camera.projectionMatrix.makePerspective(
                (-halfW - head.x) * scale,
                (halfW - head.x) * scale,
                (halfH - head.y) * scale,
                (-halfH - head.y) * scale,
                NEAR, FAR
            );
        }

        // --- Update Environment/Tunnel based on viewer position ---
        function updateEnvironment(time) {
            if (!environmentGroup) return;

            const viewerX = state.viewerPosition.x;
            const viewerY = state.viewerPosition.y;
            const viewerZ = state.viewerPosition.z;

            // Shift the tunnel slightly opposite to viewer movement
            // This creates the effect of "peering into" the tunnel
            const shiftX = -viewerX * params.tunnelShift * 0.05;
            const shiftY = -viewerY * params.tunnelShift * 0.05;

            // Tilt the tunnel based on viewer position
            // When viewer moves right, tunnel tilts slightly left (and vice versa)
            // This enhances the "looking down the corridor" feel
            const tiltY = -viewerX * params.tunnelTilt * 0.003;
            const tiltX = viewerY * params.tunnelTilt * 0.003;

            // Add subtle breathing/floating motion to the tunnel
            const breatheY = Math.sin(time * 0.3) * 0.1 * params.idleMotion;
            const breatheX = Math.sin(time * 0.2) * 0.05 * params.idleMotion;

            // Apply smooth interpolation
            environmentGroup.position.x = THREE.MathUtils.lerp(
                environmentGroup.position.x,
                shiftX + breatheX,
                params.smoothing * 0.5
            );
            environmentGroup.position.y = THREE.MathUtils.lerp(
                environmentGroup.position.y,
                shiftY + breatheY,
                params.smoothing * 0.5
            );

            // Apply tilt rotation
            environmentGroup.rotation.y = THREE.MathUtils.lerp(
                environmentGroup.rotation.y,
                tiltY,
                params.smoothing * 0.8
            );
            environmentGroup.rotation.x = THREE.MathUtils.lerp(
                environmentGroup.rotation.x,
                tiltX,
                params.smoothing * 0.8
            );

            // Subtle Z rotation for extra depth feel
            const tiltZ = viewerX * params.tunnelTilt * 0.001;
            environmentGroup.rotation.z = THREE.MathUtils.lerp(
                environmentGroup.rotation.z,
                tiltZ,
                params.smoothing * 0.5
            );
        }

        // --- Walking Animation Update ---
        function updateWalking(time, delta) {
            if (!params.useGLTFModel || !headGroup) return;

            // Only move if walking animation is active
            if (animState.currentAnim === 'walking') {
                // Move position
                animState.position += animState.direction * animState.speed * delta;

                // Check bounds and reverse direction
                if (animState.position > animState.rightBound) {
                    animState.position = animState.rightBound;
                    animState.direction = -1;
                } else if (animState.position < animState.leftBound) {
                    animState.position = animState.leftBound;
                    animState.direction = 1;
                }

                // Apply position to model
                headGroup.position.x = animState.position;

                // Rotate model to face walking direction
                if (gltfModel) {
                    const targetWalkRot = animState.direction > 0 ? -Math.PI / 2 : Math.PI / 2;
                    gltfModel.rotation.y = THREE.MathUtils.lerp(
                        gltfModel.rotation.y,
                        targetWalkRot,
                        params.smoothing * 2
                    );
                }
            } else {
                // Standing or dancing - face forward (toward viewer)
                if (gltfModel) {
                    gltfModel.rotation.y = THREE.MathUtils.lerp(
                        gltfModel.rotation.y,
                        0,
                        params.smoothing
                    );
                }
                // Keep at current position (or center)
                headGroup.position.x = animState.position;
            }
        }

        // --- Head Look-At with Idle Motion ---
        function updateHeadLookAt(time) {
            if (!headGroup) return;

            const viewerPos = state.viewerPosition.clone();

            // If using GLTF with head bone, rotate the bone instead of the whole group
            if (params.useGLTFModel && headBone) {
                const headWorldPos = new THREE.Vector3();
                headBone.getWorldPosition(headWorldPos);
                const lookDir = viewerPos.clone().sub(headWorldPos);

                // Calculate angles relative to head bone
                const angleY = Math.atan2(lookDir.x, lookDir.z) * params.headTrackStrength * 0.5;
                const horizontalDist = Math.sqrt(lookDir.x * lookDir.x + lookDir.z * lookDir.z);
                const verticalAngle = Math.atan2(-lookDir.y, horizontalDist);
                const verticalBoost = 1.0 + Math.abs(verticalAngle) * 0.5;
                const angleX = verticalAngle * params.headTrackStrength * verticalBoost * 0.5;

                // Apply to head bone (relative rotation)
                const maxRotY = Math.PI / 4;
                const maxRotX = Math.PI / 5;

                const targetRotY = THREE.MathUtils.clamp(angleY, -maxRotY, maxRotY);
                const targetRotX = THREE.MathUtils.clamp(angleX, -maxRotX, maxRotX);

                // Store original rotation if not set
                if (!headBone.userData.originalRotation) {
                    headBone.userData.originalRotation = headBone.rotation.clone();
                }

                const orig = headBone.userData.originalRotation;
                headBone.rotation.y = THREE.MathUtils.lerp(headBone.rotation.y, orig.y + targetRotY, params.smoothing * 2);
                headBone.rotation.x = THREE.MathUtils.lerp(headBone.rotation.x, orig.x + targetRotX, params.smoothing * 2);

                // Also rotate neck slightly if available
                if (neckBone) {
                    if (!neckBone.userData.originalRotation) {
                        neckBone.userData.originalRotation = neckBone.rotation.clone();
                    }
                    const neckOrig = neckBone.userData.originalRotation;
                    neckBone.rotation.y = THREE.MathUtils.lerp(neckBone.rotation.y, neckOrig.y + targetRotY * 0.3, params.smoothing);
                    neckBone.rotation.x = THREE.MathUtils.lerp(neckBone.rotation.x, neckOrig.x + targetRotX * 0.3, params.smoothing);
                }

                return; // Don't rotate the whole group if using bones
            }

            // Fallback: rotate the whole headGroup (for procedural head or models without bones)
            const headPos = new THREE.Vector3();
            headGroup.getWorldPosition(headPos);
            const lookDir = viewerPos.clone().sub(headPos);

            // Calculate base angles for tracking
            const angleY = Math.atan2(lookDir.x, lookDir.z) * params.headTrackStrength;

            // Enhanced vertical tracking - more responsive when looking from above/below
            const horizontalDist = Math.sqrt(lookDir.x * lookDir.x + lookDir.z * lookDir.z);
            const verticalAngle = Math.atan2(-lookDir.y, horizontalDist);
            // Apply stronger vertical response for extreme angles
            const verticalBoost = 1.0 + Math.abs(verticalAngle) * 0.5;
            const angleX = verticalAngle * params.headTrackStrength * verticalBoost;

            // Add head tilt (Z rotation) based on horizontal movement
            const angleZ = -angleY * params.headTilt * 0.3;

            // Add subtle idle motion (breathing, micro-movements)
            const idleY = Math.sin(time * 0.5) * 0.02 * params.idleMotion;
            const idleX = Math.sin(time * 0.3) * 0.015 * params.idleMotion;
            const idleZ = Math.sin(time * 0.7) * 0.01 * params.idleMotion;

            const maxRotY = Math.PI / 2.2;  // Allow more horizontal rotation
            const maxRotX = Math.PI / 2.5;  // Allow more vertical rotation (look up/down more)
            const maxRotZ = Math.PI / 8;

            const targetRotY = THREE.MathUtils.clamp(angleY + idleY, -maxRotY, maxRotY);
            const targetRotX = THREE.MathUtils.clamp(angleX + idleX, -maxRotX, maxRotX);
            const targetRotZ = THREE.MathUtils.clamp(angleZ + idleZ, -maxRotZ, maxRotZ);

            // Smooth rotation with all three axes
            headGroup.rotation.y = THREE.MathUtils.lerp(headGroup.rotation.y, targetRotY, params.smoothing * 1.5);
            headGroup.rotation.x = THREE.MathUtils.lerp(headGroup.rotation.x, targetRotX, params.smoothing * 1.5);
            headGroup.rotation.z = THREE.MathUtils.lerp(headGroup.rotation.z, targetRotZ, params.smoothing * 1.2);

            // Direct eye-to-eye contact tracking
            // Use the user's individual eye positions for more precise gaze
            if (eyeLeftGroup && eyeRightGroup) {
                // Calculate where each of the 3D head's eyes should look
                // to meet the user's eyes directly

                // User's left eye position in world space (relative to screen center)
                const userLeftEyeX = (0.5 - userEyes.left.x) * SCREEN_WIDTH_CM * 2.5;
                const userLeftEyeY = (0.5 - userEyes.left.y) * SCREEN_HEIGHT_CM * 2.0;

                // User's right eye position
                const userRightEyeX = (0.5 - userEyes.right.x) * SCREEN_WIDTH_CM * 2.5;
                const userRightEyeY = (0.5 - userEyes.right.y) * SCREEN_HEIGHT_CM * 2.0;

                // 3D head's left eye should look at user's right eye (mirror)
                // 3D head's right eye should look at user's left eye (mirror)
                const leftEyeLookX = userRightEyeX;
                const leftEyeLookY = userRightEyeY;
                const rightEyeLookX = userLeftEyeX;
                const rightEyeLookY = userLeftEyeY;

                // Calculate individual eye angles
                const eyeZ = state.viewerPosition.z;

                // Left eye of 3D head
                const leftAngleY = Math.atan2(leftEyeLookX - (-2.5 * params.modelScale), eyeZ) * params.eyeTrackStrength;
                const leftAngleX = Math.atan2(-leftEyeLookY, eyeZ) * params.eyeTrackStrength;

                // Right eye of 3D head
                const rightAngleY = Math.atan2(rightEyeLookX - (2.5 * params.modelScale), eyeZ) * params.eyeTrackStrength;
                const rightAngleX = Math.atan2(-rightEyeLookY, eyeZ) * params.eyeTrackStrength;

                const maxEyeRot = Math.PI / 4;

                // Apply to left eye
                const leftTargetY = THREE.MathUtils.clamp(leftAngleY, -maxEyeRot, maxEyeRot);
                const leftTargetX = THREE.MathUtils.clamp(leftAngleX, -maxEyeRot, maxEyeRot);

                // Apply to right eye
                const rightTargetY = THREE.MathUtils.clamp(rightAngleY, -maxEyeRot, maxEyeRot);
                const rightTargetX = THREE.MathUtils.clamp(rightAngleX, -maxEyeRot, maxEyeRot);

                // Faster, more responsive eye movement
                eyeLeftGroup.rotation.y = THREE.MathUtils.lerp(eyeLeftGroup.rotation.y, leftTargetY, params.smoothing * 3);
                eyeLeftGroup.rotation.x = THREE.MathUtils.lerp(eyeLeftGroup.rotation.x, leftTargetX, params.smoothing * 3);
                eyeRightGroup.rotation.y = THREE.MathUtils.lerp(eyeRightGroup.rotation.y, rightTargetY, params.smoothing * 3);
                eyeRightGroup.rotation.x = THREE.MathUtils.lerp(eyeRightGroup.rotation.x, rightTargetX, params.smoothing * 3);
            }
        }

        // --- Face Tracking ---
        async function startTracking() {
            try {
                const video = document.getElementById('debug-video');
                const canvas = document.getElementById('debug-canvas');
                const ctx = canvas.getContext('2d');

                const faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });

                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                faceMesh.onResults(results => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

                    if (results.multiFaceLandmarks.length > 0) {
                        state.trackingActive = true;
                        const lm = results.multiFaceLandmarks[0];
                        const lIris = lm[468], rIris = lm[473];

                        if (lIris && rIris) {
                            // Store individual eye positions for eye-to-eye contact
                            userEyes.left.set(lIris.x, lIris.y);
                            userEyes.right.set(rIris.x, rIris.y);
                            userEyes.centerX = (lIris.x + rIris.x) / 2;
                            userEyes.centerY = (lIris.y + rIris.y) / 2;

                            const cx = userEyes.centerX;
                            const cy = userEyes.centerY;

                            const dx = lIris.x - rIris.x;
                            const dy = lIris.y - rIris.y;
                            const dPx = Math.sqrt(dx * dx + dy * dy);

                            let z = 4.5 / dPx;
                            z = THREE.MathUtils.clamp(z, 15, 120);

                            const SENSITIVITY = 2.5;
                            const wx = (0.5 - cx) * SCREEN_WIDTH_CM * SENSITIVITY;
                            // Use verticalSensitivity for better vertical tracking
                            const wy = (0.5 - cy) * SCREEN_HEIGHT_CM * SENSITIVITY * params.verticalSensitivity;

                            state.targetHead.set(
                                THREE.MathUtils.clamp(wx, -60, 60),
                                THREE.MathUtils.clamp(wy, -80, 80),  // Increased vertical range
                                z
                            );

                            // Debug viz - show both eyes being tracked
                            ctx.fillStyle = '#00ffff';
                            ctx.shadowColor = '#00ffff';
                            ctx.shadowBlur = 10;

                            // Left eye (user's)
                            ctx.beginPath();
                            ctx.arc(lIris.x * canvas.width, lIris.y * canvas.height, 3, 0, Math.PI * 2);
                            ctx.fill();

                            // Right eye (user's)
                            ctx.beginPath();
                            ctx.arc(rIris.x * canvas.width, rIris.y * canvas.height, 3, 0, Math.PI * 2);
                            ctx.fill();

                            // Center point
                            ctx.fillStyle = '#ff0080';
                            ctx.beginPath();
                            ctx.arc(cx * canvas.width, cy * canvas.height, 2, 0, Math.PI * 2);
                            ctx.fill();

                            // Draw connecting line between eyes
                            ctx.strokeStyle = '#00ffff';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(lIris.x * canvas.width, lIris.y * canvas.height);
                            ctx.lineTo(rIris.x * canvas.width, rIris.y * canvas.height);
                            ctx.stroke();

                            ctx.fillStyle = '#00ffff';
                            ctx.font = '10px Courier New';
                            ctx.fillText(`DIST: ${z.toFixed(0)}cm`, 5, 15);
                            ctx.fillText(`EYES LOCKED`, 5, 27);
                        }
                    }
                });

                const mediapipeCamera = new Camera(video, {
                    onFrame: async () => await faceMesh.send({ image: video }),
                    width: 640,
                    height: 480
                });

                await mediapipeCamera.start();
                document.getElementById('overlay').style.display = 'none';

            } catch (e) {
                console.error(e);
                document.getElementById('status').innerText = "ERROR: " + e.message;
            }
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('status').innerText = "INITIALIZING NEURAL LINK...";
            startTracking();
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update GLTF animation mixer if it exists
            if (gltfMixer) {
                gltfMixer.update(delta);
            }

            // Update uniforms
            if (gridUniforms) gridUniforms.time.value = time * params.gridSpeed;
            if (headPointsUniforms) {
                headPointsUniforms.time.value = time * params.pulseSpeed;
                headPointsUniforms.glowIntensity.value = params.glowIntensity;
                headPointsUniforms.size.value = params.particleSize;
            }
            if (headWireUniforms) {
                headWireUniforms.time.value = time * params.pulseSpeed;
                headWireUniforms.opacity.value = params.wireframeOpacity;
            }

            // Update eye materials
            if (eyeLeftGroup && eyeLeftGroup.children[0]) {
                eyeLeftGroup.children[0].material.uniforms.time.value = time;
                eyeRightGroup.children[0].material.uniforms.time.value = time;
            }

            // Update blinking
            updateBlink(time, delta);

            // Update mouth animation
            updateMouth(time, delta);

            // Update walking animation
            updateWalking(time, delta);

            // Smooth tracking
            state.head.lerp(state.targetHead, params.smoothing);
            state.viewerPosition.copy(state.head);

            updateCamera(state.head);
            updateEnvironment(time);
            updateHeadLookAt(time);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(console.warn);
            } else {
                document.exitFullscreen();
            }
        });

        document.addEventListener('fullscreenchange', () => {
            document.getElementById('fullscreen-btn').textContent =
                document.fullscreenElement ? '[ EXIT ]' : '[ FULLSCREEN ]';
        });

        // --- Speech Controls ---
        document.getElementById('speak-btn').addEventListener('click', () => {
            const text = document.getElementById('speech-input').value.trim();
            if (text) {
                speak(text);
                document.getElementById('speech-input').value = '';
            }
        });

        document.getElementById('random-btn').addEventListener('click', () => {
            speakRandom();
        });

        document.getElementById('speech-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const text = e.target.value.trim();
                if (text) {
                    speak(text);
                    e.target.value = '';
                }
            }
        });

        // Pre-load voices
        if (speechState.speechSynth) {
            speechState.speechSynth.getVoices();
        }
    </script>
</body>

</html>
